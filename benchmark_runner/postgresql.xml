<?xml version="1.0" encoding="utf-8"?>
<sql_benchmark>
  <name>SQL Benchmark 1</name>
  <author></author>
  <description></description>
  <init_script>
    <statements>
      <statement>
        <command_text>DROP TABLE IF EXISTS TestTable;

 </command_text>
      </statement>
      <statement>
        <command_text>CREATE  TABLE TestTable AS
WITH x AS 
(
  SELECT 0 n
  UNION ALL 
  SELECT 1
  UNION ALL 
  SELECT 2
  UNION ALL 
  SELECT 3
  UNION ALL 
  SELECT 4
  UNION ALL 
  SELECT 5
  UNION ALL 
  SELECT 6
  UNION ALL 
  SELECT 9
  UNION ALL 
  SELECT 8
  UNION ALL 
  SELECT 9
), t1 AS
(
  SELECT ones.n + 10 * tens.n + 100 * hundreds.n  + 1000 * thousands.n + 10000 * tenthousands.n + 100000 * hundredthousands.n AS id  
  FROM x ones,     x tens,      x hundreds,       x thousands,       x tenthousands,       x hundredthousands
), t2 AS
(
    SELECT  id,
            mod(id, 100) groupby
    FROM t1
), t3 AS
(
    SELECT  b.id, b.groupby, row_number() over (partition by groupby ORDER BY id) orderby
    FROM t2 b
)
SELECT  id, 
        groupby, 
        CAST(orderby AS INT) orderby,
        CAST(mod(orderby, (groupby * 100 + 1)) AS INT) local_search, 
        mod(id, 10000) global_search, 
        RPAD(concat('Value ', id), 1000, '*') AS padding    
FROM t3
</command_text>
      </statement>
      <statement>
        <command_text>insert into TestTable(id, groupby, orderby, local_search, global_search, padding) values (1000000, null, null, null, null, '*')</command_text>
      </statement>
      <statement>
        <command_text>insert into TestTable(id, groupby, orderby, local_search, global_search, padding) values (1000001, 100, null, null, null, '*')</command_text>
      </statement>
      <statement>
        <command_text>insert into TestTable(id, groupby, orderby, local_search, global_search, padding) values (1000002, 99, 10000, null, null, '*')
</command_text>
      </statement>
    </statements>
  </init_script>
  <clean_up_script>
    <statements>
      <statement>
        <command_text>DROP TABLE IF EXISTS TestTable;
</command_text>
      </statement>
    </statements>
  </clean_up_script>
  <test_groups>
    <test_group>
      <id>1</id>
      <name>01</name>
      <description></description>
      <tests>
        <test>
          <id>2</id>
          <name>Sargability 1</name>
          <description>Test of predicate sargability.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>3</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where a.local_search - 5 = 990</command_text>
              </statement>
            </variant>
            <variant>
              <id>4</id>
              <name>Constant rewrite</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where a.local_search = 995</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>260</expected_result_size>
        </test>
        <test>
          <id>5</id>
          <name>Sargability 2</name>
          <description>Test of attribute sargability II.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>6</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where a.local_search + 10 = a.global_search - 10</command_text>
              </statement>
            </variant>
            <variant>
              <id>7</id>
              <name>Constant rewrite</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where a.local_search = a.global_search - 20</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>174</expected_result_size>
        </test>
        <test>
          <id>8</id>
          <name>Predicate ordering</name>
          <description>Test of predicate ordering of conjuctive query (predicates with different selectivity)</description>
          <active>True</active>
          <variants>
            <variant>
              <id>9</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where a.local_search = 1 and a.global_search &lt; 100</command_text>
              </statement>
            </variant>
            <variant>
              <id>10</id>
              <name>Swap of predicates</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where a.global_search &lt; 100 and a.local_search = 1</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>99</expected_result_size>
        </test>
        <test>
          <id>11</id>
          <name>Disjunction using IN</name>
          <description>Test of different disjunction syntax.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>12</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where a.local_search = 1000 or a.local_search = 5000</command_text>
              </statement>
            </variant>
            <variant>
              <id>13</id>
              <name>IN</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where a.local_search in (1000, 5000)</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>306</expected_result_size>
        </test>
        <test>
          <id>14</id>
          <name>Predicate elimination 1</name>
          <description>Test of a predicate elimination. The first SQL query contains a predicate that has to be always evaluated to true and it can be eliminated.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>15</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where (1 = 2 and a.global_search = 2) or
      (1 = 1 and a.local_search = 1)</command_text>
              </statement>
            </variant>
            <variant>
              <id>16</id>
              <name>Predicate elimination</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where a.local_search = 1</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>572</expected_result_size>
        </test>
        <test>
          <id>17</id>
          <name>Predicate elimination 2</name>
          <description>Test of a predicate elimination.
 The first SQL query contains predicates that has to be always evaluated to true and 
it can be safely eliminated.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>18</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where a.global_search &gt; 40 and a.global_search &lt; 45 and
      a.global_search &gt; 10 and a.global_search &lt; 200</command_text>
              </statement>
            </variant>
            <variant>
              <id>19</id>
              <name>Predicate elimination</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where a.global_search &gt; 40 and a.global_search &lt; 45</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>400</expected_result_size>
        </test>
        <test>
          <id>20</id>
          <name>De Morgan law</name>
          <description>Test of disjunction.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>21</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where NOT (a.local_search != 1 or a.global_search != 2)</command_text>
              </statement>
            </variant>
            <variant>
              <id>22</id>
              <name>De Morgan law</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where a.local_search = 1 and a.global_search = 2</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>1</expected_result_size>
        </test>
        <test>
          <id>23</id>
          <name>Disjunction using UNION</name>
          <description>Test of disjunction. Rewrite of a disjunction into a query using the UNION construct.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>24</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where a.local_search = 1000 or a.local_search = 5000</command_text>
              </statement>
            </variant>
            <variant>
              <id>25</id>
              <name>UNION</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where a.local_search = 1000
UNION
select a.id, a.local_search, a.padding
from TestTable a 
where a.local_search = 5000</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>306</expected_result_size>
        </test>
        <test>
          <id>26</id>
          <name>Conjunction using INTERSECT</name>
          <description>Test of conjunction. The `INTERSECT` construct versus the `AND` solution.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>27</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where a.local_search = 1 and a.global_search &lt; 100</command_text>
              </statement>
            </variant>
            <variant>
              <id>28</id>
              <name>Intersection</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where a.local_search = 1
intersect
select a.id, a.local_search, a.padding
from TestTable a 
where a.global_search &lt; 100</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>99</expected_result_size>
        </test>
      </tests>
      <configurations>
        <configuration>
          <id>29</id>
          <name>Heap</name>
          <description></description>
          <init_script>
            <statements />
          </init_script>
          <clean_up_script>
            <statements />
          </clean_up_script>
        </configuration>
        <configuration>
          <id>30</id>
          <name>Non-clustered 1</name>
          <description></description>
          <init_script>
            <statements>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_ls
ON TestTable (local_search)
</command_text>
              </statement>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_gs
ON TestTable (global_search)
</command_text>
              </statement>
            </statements>
          </init_script>
          <clean_up_script>
            <statements>
              <statement>
                <command_text>-- drop the indexes
drop index ix_TestTable_ls
</command_text>
              </statement>
              <statement>
                <command_text>drop index ix_TestTable_gs

</command_text>
              </statement>
            </statements>
          </clean_up_script>
        </configuration>
        <configuration>
          <id>31</id>
          <name>Non-clustered 2</name>
          <description></description>
          <init_script>
            <statements>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_ls_gs
ON TestTable (local_search, global_search)</command_text>
              </statement>
            </statements>
          </init_script>
          <clean_up_script>
            <statements>
              <statement>
                <command_text>drop index ix_TestTable_ls_gs</command_text>
              </statement>
            </statements>
          </clean_up_script>
        </configuration>
        <configuration>
          <id>32</id>
          <name>Non-clustered 3</name>
          <description></description>
          <init_script>
            <statements>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_gs_ls
ON TestTable (global_search, local_search)</command_text>
              </statement>
            </statements>
          </init_script>
          <clean_up_script>
            <statements>
              <statement>
                <command_text>drop index ix_TestTable_gs_ls</command_text>
              </statement>
            </statements>
          </clean_up_script>
        </configuration>
      </configurations>
    </test_group>
    <test_group>
      <id>37</id>
      <name>02</name>
      <description></description>
      <tests>
        <test>
          <id>38</id>
          <name>HAVING vs subquery</name>
          <description>Rewrite of the HAVING into a subquery.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>39</id>
              <name>HAVING variant</name>
              <description></description>
              <statement>
                <command_text>select groupby
from TestTable
group by groupby
having sum(local_search) &lt; 1000000</command_text>
              </statement>
            </variant>
            <variant>
              <id>40</id>
              <name>Subquery variant</name>
              <description></description>
              <statement>
                <command_text>select groupby
from (select distinct groupby from TestTable) t
where 1000000 &gt; (
  select sum(local_search)
  from TestTable t2
  where t2.groupby = t.groupby
)</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>3</expected_result_size>
        </test>
        <test>
          <id>41</id>
          <name>Property groups</name>
          <description>Rewrite of the HAVING into a EXISTS or INTERSECT. 
This is quite common non-trivial task where we search for groups having certain set of properties. We can look on the problem as variants for the intersection of sets.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>42</id>
              <name>HAVING variant</name>
              <description></description>
              <statement>
                <command_text>select groupby
from TestTable
where local_search in (500, 501)
group by groupby
having count(distinct local_search) = 2</command_text>
              </statement>
            </variant>
            <variant>
              <id>43</id>
              <name>EXISTS subquery variant</name>
              <description></description>
              <statement>
                <command_text>select groupby
from (
  select distinct groupby from TestTable
) a
where exists (
  select 1
  from TestTable b
  where b.local_search = 500 and
        a.groupby = b.groupby
) and exists (
  select 1
  from TestTable b
  where b.local_search = 501 and
        a.groupby = b.groupby
)</command_text>
              </statement>
            </variant>
            <variant>
              <id>44</id>
              <name>INTERSECT variant</name>
              <description></description>
              <statement>
                <command_text>select groupby
from TestTable
where local_search = 500
intersect
select groupby
from TestTable
where local_search = 501</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>94</expected_result_size>
        </test>
        <test>
          <id>45</id>
          <name>Exceptional groups</name>
          <description>We search for groups where all rows in group satisfy certain condition. It is a specific type of a set difference.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>46</id>
              <name>HAVING variant</name>
              <description></description>
              <statement>
                <command_text>select groupby
from TestTable
group by groupby
having count(case when local_search &lt; 600 or local_search IS NULL then 1 end) = count(*)</command_text>
              </statement>
            </variant>
            <variant>
              <id>47</id>
              <name>NOT EXISTS subquery variant</name>
              <description></description>
              <statement>
                <command_text>select groupby
from (
  select distinct groupby from TestTable
) a
where not exists (
  select 1
  from TestTable b
  where b.local_search &gt;= 600 and
        a.groupby = b.groupby
)</command_text>
              </statement>
            </variant>
            <variant>
              <id>48</id>
              <name>DIFFERENCE variant</name>
              <description></description>
              <statement>
                <command_text>select distinct groupby
from TestTable
minus
select groupby
from TestTable
where local_search &gt;= 600</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>8</expected_result_size>
        </test>
        <test>
          <id>49</id>
          <name>Aggregate function elimination</name>
          <description>Rewrite of the HAVING condition which eliminate one aggregate function. This rewrite comes from a precondition that we have two stes A and B, if A intersection B equals to A then complement A to B equals to zero.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>50</id>
              <name>HAVING with two aggregates</name>
              <description></description>
              <statement>
                <command_text>select groupby
from TestTable
group by groupby
having count(case when local_search &lt; 600 or local_search IS NULL then 1 end) = count(*)</command_text>
              </statement>
            </variant>
            <variant>
              <id>51</id>
              <name>HAVING with one aggregate</name>
              <description></description>
              <statement>
                <command_text>select groupby
from TestTable
group by groupby
having count(case when local_search &gt;= 600 then 1 end) = 0</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>8</expected_result_size>
        </test>
        <test>
          <id>52</id>
          <name>Window function vs subquery</name>
          <description>Rewrite of a window function using a correlated subquery with aggregate. This kind of rewrite is possible if the value generated by window function is compared to some constant.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>53</id>
              <name>Window function variant</name>
              <description></description>
              <statement>
                <command_text>select id, 
       groupby, 
       local_search, 
       count(*) over (partition by groupby) ct
from TestTable
where id &lt; 100</command_text>
              </statement>
            </variant>
            <variant>
              <id>247</id>
              <name>Subquery variant</name>
              <description></description>
              <statement>
                <command_text>select id, 
       groupby, 
       local_search, 
       (
         select count(*) 
         from TestTable b
         where b.groupby = a.groupby
       ) ct
from TestTable a
where id &lt; 100</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>100</expected_result_size>
        </test>
        <test>
          <id>55</id>
          <name>Conditional aggregation high-sel</name>
          <description>Conditional aggreagtion vesus solution using subquery with distinct. This test uses a high selectivity condition in the predicate (one row per group).</description>
          <active>True</active>
          <variants>
            <variant>
              <id>56</id>
              <name>Conditional aggregation</name>
              <description></description>
              <statement>
                <command_text>select groupby,
       count(case when local_search = 1 then 1 end) as orderby1,
       count(case when local_search = 2 then 1 end) as orderby2
from TestTable
group by groupby</command_text>
              </statement>
            </variant>
            <variant>
              <id>57</id>
              <name>Subquery + distinct</name>
              <description></description>
              <statement>
                <command_text>select distinct g1.groupby,
       (select count(*) from TestTable g2 where local_search = 1 and g1.groupby = g2.groupby) as orderby1,
       (select count(*) from TestTable g2 where local_search = 2 and g1.groupby = g2.groupby) as orderby2
from TestTable g1</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>102</expected_result_size>
        </test>
        <test>
          <id>58</id>
          <name>Aggregation pushdown with subquery</name>
          <description>This test compares two queries where one have the aggregation nested in a subquery. It is equivalent since there are no joins and `g1.groupby` is the only attribute from the outer query that is used in the subqueries.
</description>
          <active>True</active>
          <variants>
            <variant>
              <id>59</id>
              <name>Subquery + distinct</name>
              <description></description>
              <statement>
                <command_text>select distinct g1.groupby,
       (select count(*) from TestTable g2 where local_search = 1 and g1.groupby = g2.groupby) as cnt
from TestTable g1</command_text>
              </statement>
            </variant>
            <variant>
              <id>60</id>
              <name>Subuqyer + distinct in subquery</name>
              <description></description>
              <statement>
                <command_text>select g1.groupby,
       (select count(*) from TestTable g2 where local_search = 1 and g1.groupby = g2.groupby) as cnt
from (select distinct groupby from TestTable) g1</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>102</expected_result_size>
        </test>
        <test>
          <id>61</id>
          <name>Conditional aggregation med-sel</name>
          <description>The test compare a conditional aggregation query with a query using subquery with distinct. 
-- This test uses a medium selectivity condition in the predicate (50% of rows per group).</description>
          <active>True</active>
          <variants>
            <variant>
              <id>62</id>
              <name>Conditional aggregation</name>
              <description></description>
              <statement>
                <command_text>select groupby,
       count(case when local_search &lt; 1000 then 1 end) as orderby1,
       count(case when local_search &gt; 7500 then 1 end) as orderby2
from TestTable
group by groupby</command_text>
              </statement>
            </variant>
            <variant>
              <id>63</id>
              <name>Subquery + distinct</name>
              <description></description>
              <statement>
                <command_text>select distinct g1.groupby,
       (select count(*) from TestTable g2 where local_search &lt; 1000 and g1.groupby = g2.groupby) as orderby1,
       (select count(*) from TestTable g2 where local_search &gt; 7500 and g1.groupby = g2.groupby) as orderby2
from TestTable g1</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>102</expected_result_size>
        </test>
        <test>
          <id>64</id>
          <name>Conditional aggregation low-sel</name>
          <description>Conditional aggreagtion versus solution using subquery with distinct. 
This test uses a medium selectivity condition in the predicate (100% of rows per group).</description>
          <active>True</active>
          <variants>
            <variant>
              <id>65</id>
              <name>Conditional aggregation</name>
              <description></description>
              <statement>
                <command_text>select groupby,
       count(case when local_search &lt; 5000 then 1 end) as orderby1,
       count(case when local_search &gt; 5000 then 1 end) as orderby2
from TestTable
group by groupby</command_text>
              </statement>
            </variant>
            <variant>
              <id>66</id>
              <name>Subquery + distinct</name>
              <description></description>
              <statement>
                <command_text>select distinct g1.groupby,
       (select count(*) from TestTable g2 where local_search &lt; 5000 and g1.groupby = g2.groupby) as orderby1,
       (select count(*) from TestTable g2 where local_search &gt; 5000 and g1.groupby = g2.groupby) as orderby2
from TestTable g1</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>102</expected_result_size>
        </test>
        <test>
          <id>67</id>
          <name>Greatest in group 1</name>
          <description>Find rows with max `local_search` value per `groupby`. Find ALL occurences of max per `groupby`.
 We assume that there can be more than one maximum `local_search` value per one `groupby` value. This test shows the most common solutions for this problem. 
The `55_greatest_in_group_II` test shows also some other solutions.
 The window function solution usually leads to a sequential scan and to a very simple query plan.
 On the other hand the group by can utilize the indexes that are available.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>68</id>
              <name>GROUP BY</name>
              <description></description>
              <statement>
                <command_text>select t.id, t.groupby, t.local_search, t.padding
from TestTable t
join
(
    SELECT groupby, max(local_search) gmax
    from TestTable
    where groupby &gt; 25
    group by groupby
) t2 on t.groupby = t2.groupby and 
        t.local_search = t2.gmax
</command_text>
              </statement>
            </variant>
            <variant>
              <id>69</id>
              <name>Window function</name>
              <description></description>
              <statement>
                <command_text>select t.id, t.groupby, t.local_search, t.padding
from
(
    select id, groupby, local_search, padding, 
            dense_rank() over (partition by groupby order by local_search desc) rn
    from TestTable
    where groupby &gt; 25 and 
          local_search is not null
) t
where t.rn = 1
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>106</expected_result_size>
        </test>
        <test>
          <id>70</id>
          <name>Greatest in group 2</name>
          <description>Find max `local_search` per `groupby`. Find all occurences.
 This test compare eight very different solutions to this problem.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>71</id>
              <name>Window function 1</name>
              <description></description>
              <statement>
                <command_text>select t.id, t.groupby, t.local_search, t.padding
from
(
    select id, groupby, local_search, padding, 
            dense_rank() over (partition by groupby order by local_search desc) rn
    from TestTable
    where groupby &gt; 25 and 
          local_search is not null
) t
where t.rn = 1
</command_text>
              </statement>
            </variant>
            <variant>
              <id>72</id>
              <name>Window function 2</name>
              <description></description>
              <statement>
                <command_text>select t.id, t.groupby, t.local_search, t.padding
from
(
    select id, groupby, local_search, padding,
            max(local_search) over (partition by groupby) maxLocalSearch
    from TestTable 
    where groupby &gt; 25

) t
where t.maxLocalSearch = t.local_search
</command_text>
              </statement>
            </variant>
            <variant>
              <id>73</id>
              <name>CROSS JOIN and TOP 1 with ties</name>
              <description></description>
              <statement>
                <command_text>select t.id, t.groupby, t.local_search, t.padding
from (
  select groupby
  from TestTable
  where groupby &gt; 25
  group by groupby
) t1
cross apply
(
    SELECT t2.id, t2.groupby, t2.local_search, t2.padding
    from TestTable t2
    where t1.groupby = t2.groupby and 
          t2.local_search is not null
    order by t2.local_search desc
    fetch first 1 row with ties
) t 
where t.local_search is not null
</command_text>
              </statement>
            </variant>
            <variant>
              <id>74</id>
              <name>GROUP BY</name>
              <description></description>
              <statement>
                <command_text>select t.id, t.groupby, t.local_search, t.padding
from TestTable t
join
(
    SELECT groupby, max(local_search) gmax
    from TestTable
    where groupby &gt; 25
    group by groupby
) t2 on t.groupby = t2.groupby and 
        t.local_search = t2.gmax
</command_text>
              </statement>
            </variant>
            <variant>
              <id>75</id>
              <name>Subquery with aggregation</name>
              <description></description>
              <statement>
                <command_text>select t.id, t.groupby, t.local_search, t.padding
from TestTable t
where t.groupby &gt; 25 and t.local_search =
    (
        SELECT max(t1.local_search) gmax
        from TestTable t1
        where t1.groupby = t.groupby
    ) 
</command_text>
              </statement>
            </variant>
            <variant>
              <id>76</id>
              <name>NOT EXISTS</name>
              <description></description>
              <statement>
                <command_text>select t.id, t.groupby, t.local_search, t.padding
from TestTable t
where NOT EXISTS
    (
        SELECT 1
        from TestTable t2
        where t2.groupby = t.groupby and
              t2.local_search &gt; t.local_search
    ) and 
    t.groupby &gt; 25 and
    t.local_search is not null
</command_text>
              </statement>
            </variant>
            <variant>
              <id>77</id>
              <name>LEFT JOIN + NULL</name>
              <description></description>
              <statement>
                <command_text>select t.id, t.groupby, t.local_search, t.padding
from TestTable t
left join TestTable t2 on t2.groupby = t.groupby and
                       t2.local_search &gt; t.local_search
where t.groupby &gt; 25 and
      t.local_search is not null and
      t2.groupby is null
</command_text>
              </statement>
            </variant>
            <variant>
              <id>78</id>
              <name>TOP 1 with ties</name>
              <description></description>
              <statement>
                <command_text>select t.id, t.groupby, t.local_search, t.padding
from TestTable t
where t.groupby &gt; 25 and
      t.local_search is not null
order by dense_rank() over (partition by groupby order by local_search desc)
fetch first 1 row with ties
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>106</expected_result_size>
        </test>
        <test>
          <id>79</id>
          <name>Greatest N per group</name>
          <description>Two solutions for the problem:
 "Find N max occurences per group."
 More specificaly for each `groupby` value we search  for 5 rows with highest `local_search`.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>80</id>
              <name>Window fun</name>
              <description></description>
              <statement>
                <command_text>select t.id, t.groupby, t.local_search, t.padding
from
(
   select id, groupby, local_search, padding,
       row_number() over (partition by groupby order by local_search desc) rn
   from TestTable
   where groupby &gt; 80
) t
where t.rn &lt;= 5</command_text>
              </statement>
            </variant>
            <variant>
              <id>81</id>
              <name>CROSS APPLY</name>
              <description></description>
              <statement>
                <command_text>select t.id, t.groupby, t.local_search, t.padding
from (
  select groupby
  from TestTable
  where groupby &gt; 80
  group by groupby
) t1
cross apply
(
    SELECT t2.id, t2.groupby, t2.local_search, t2.padding
    from TestTable t2
    where t1.groupby = t2.groupby
    order by t2.local_search desc
    fetch first 5 rows only
) t
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>96</expected_result_size>
        </test>
        <test>
          <id>82</id>
          <name>GROUP BY elimination</name>
          <description>We test the capability to omit an unnecessary `GROUP BY` clause.
 The grouping is performed on one group, therefore, there is no need to do include the GROUP BY.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>83</id>
              <name>GROUP BY</name>
              <description></description>
              <statement>
                <command_text>SELECT groupby, max(local_search) gmax
from TestTable
where groupby = 1
group by groupby
</command_text>
              </statement>
            </variant>
            <variant>
              <id>84</id>
              <name>GROUP BY eliminated</name>
              <description></description>
              <statement>
                <command_text>SELECT 1 as groupby, max(local_search) gmax
from TestTable
where groupby = 1
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>1</expected_result_size>
        </test>
        <test>
          <id>85</id>
          <name>GROUP BY elimination in subquery</name>
          <description></description>
          <active>True</active>
          <variants>
            <variant>
              <id>86</id>
              <name>GROUP BY</name>
              <description></description>
              <statement>
                <command_text>select t2.*
from TestTable t2
join
(
    select groupby, max(local_search) gmax
    from TestTable
    group by groupby
) t on t2.groupby = t.groupby and
       t2.local_search = t.gmax and
       t2.groupby = 1
</command_text>
              </statement>
            </variant>
            <variant>
              <id>87</id>
              <name>GROUP BY eliminated</name>
              <description></description>
              <statement>
                <command_text>select t2.*
from TestTable t2
join
(
    select max(local_search) gmax
    from TestTable
    where groupby = 1
) t on t2.local_search = t.gmax and 
       groupby = 1
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>99</expected_result_size>
        </test>
        <test>
          <id>88</id>
          <name>Correlated subquery elimination</name>
          <description>We test the capability to omit unnecessary correlation in a subquery.
 The correlation is unnecessary since the outer query has a specific predicate on the correlation attribute.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>89</id>
              <name>Correlated subquery</name>
              <description></description>
              <statement>
                <command_text>select t.*
from TestTable t
where local_search = (
  select max(local_search)
  from TestTable t2
  where t2.groupby = t.groupby
) and t.groupby = 1
</command_text>
              </statement>
            </variant>
            <variant>
              <id>90</id>
              <name>Independent subquery</name>
              <description></description>
              <statement>
                <command_text>select t.*
from TestTable t
where local_search = (
  select max(local_search) gmax
  from TestTable t2
  where t2.groupby = 1
) and t.groupby = 1
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>99</expected_result_size>
        </test>
        <test>
          <id>91</id>
          <name>Compute column liftup</name>
          <description>Is it better to do the TOP X in a subquery and then the column computation or it does not matter?
 Here we test whether the query compiler is capable to lift the column computation up if possible.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>92</id>
              <name>Basic computation</name>
              <description></description>
              <statement>
                <command_text>select id, 
   groupby, 
   local_search,
   padding, 
   row_number() over (partition by groupby order by id)
from TestTable
order by groupby desc, local_search desc
offset 0 ROWS 
fetch next 50 rows only
</command_text>
              </statement>
            </variant>
            <variant>
              <id>93</id>
              <name>Using subquery</name>
              <description></description>
              <statement>
                <command_text>select t.id,
       t.groupby,
       t.local_search,
       t.padding,
       row_number() over (partition by t.groupby order by t.id)
from
(
    select id, 
           groupby, 
           local_search,
           padding
    from TestTable
    order by groupby desc, local_search desc
    offset 0 ROWS 
    fetch next 50 rows only
) t
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>50</expected_result_size>
        </test>
        <test>
          <id>94</id>
          <name>Removing conditional aggregation</name>
          <description>This test remove the conditional aggregation since the CASE condition has to be always satisfied.
 That is caused by the fact that the condition is already in WHERE predicate.
 Please note that removing the COUNT CASE is tricky and we should be aware of NULLs.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>95</id>
              <name>Conditional aggregation</name>
              <description></description>
              <statement>
                <command_text>select g1.groupby,
       count(case when local_search = 1 then 1 end) as c,
       max(case when local_search = 1 then local_search end) as local_search
from TestTable g1
where local_search = 1 or local_search IS NULL
group by groupby
</command_text>
              </statement>
            </variant>
            <variant>
              <id>96</id>
              <name>Without CASE</name>
              <description></description>
              <statement>
                <command_text>select g1.groupby,
       count(orderby) as c,
       max(local_search) as local_search
from TestTable g1
where local_search = 1 or local_search IS NULL
group by groupby
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>101</expected_result_size>
        </test>
        <test>
          <id>227</id>
          <name>All construct versus aggregation</name>
          <description>It solves the `greatest in group` problem. Therefore, it finds max `local_search` per `groupby`. Find all occurences.
This test compare a solution utlizing the `all` construct versus `group by` solution. Both queries are using a dependent subquery.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>230</id>
              <name>All construct</name>
              <description>Dependent subquery with all construct.</description>
              <statement>
                <command_text>select t.id, t.groupby, t.local_search, t.padding
from TestTable t
where t.local_search &gt;= all(
  select local_search
  from TestTable t2
  where t.groupby = t2.groupby  and local_search is not null
) and groupby &gt; 25 and local_search is not null
</command_text>
              </statement>
            </variant>
            <variant>
              <id>231</id>
              <name>Aggregation</name>
              <description>Dependent subquery with aggregation.</description>
              <statement>
                <command_text>select t.id, t.groupby, t.local_search, t.padding
from TestTable t
where t.groupby &gt; 25 and t.local_search =
    (
        SELECT max(t1.local_search) gmax
        from TestTable t1
        where t1.groupby = t.groupby
    ) 
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>106</expected_result_size>
        </test>
      </tests>
      <configurations>
        <configuration>
          <id>97</id>
          <name>Heap</name>
          <description></description>
          <init_script>
            <statements />
          </init_script>
          <clean_up_script>
            <statements />
          </clean_up_script>
        </configuration>
        <configuration>
          <id>98</id>
          <name>Non-clustered 1</name>
          <description></description>
          <init_script>
            <statements>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_groupby_ls
ON TestTable (groupby,local_search)</command_text>
              </statement>
            </statements>
          </init_script>
          <clean_up_script>
            <statements>
              <statement>
                <command_text>drop index ix_TestTable_groupby_ls</command_text>
              </statement>
            </statements>
          </clean_up_script>
        </configuration>
        <configuration>
          <id>99</id>
          <name>Non-clustered 2</name>
          <description></description>
          <init_script>
            <statements>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_ls
ON TestTable (local_search,groupby)</command_text>
              </statement>
            </statements>
          </init_script>
          <clean_up_script>
            <statements>
              <statement>
                <command_text>drop index ix_TestTable_ls
</command_text>
              </statement>
            </statements>
          </clean_up_script>
        </configuration>
      </configurations>
    </test_group>
    <test_group>
      <id>102</id>
      <name>03</name>
      <description></description>
      <tests>
        <test>
          <id>103</id>
          <name>Selection pushdown</name>
          <description>Testing the selection pushdown.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>104</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.orderby, b.padding
from TestTable a
join TestTable b on b.local_search = a.id
where a.global_search = 1 and b.groupby = 10
</command_text>
              </statement>
            </variant>
            <variant>
              <id>105</id>
              <name>Selection pushdown</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.orderby, b.padding
from 
(
    select * from TestTable b where b.groupby = 10
) b
join 
(
    select * from TestTable where global_search = 1
) a on b.local_search = a.id
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>10</expected_result_size>
        </test>
        <test>
          <id>106</id>
          <name>CROSS JOIN</name>
          <description>Rewriting join to a cross join</description>
          <active>True</active>
          <variants>
            <variant>
              <id>107</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.orderby, b.padding
from TestTable a
join TestTable b on b.local_search = a.id
where a.global_search = 1 and b.groupby = 10
</command_text>
              </statement>
            </variant>
            <variant>
              <id>108</id>
              <name>CROSS JOIN</name>
              <description></description>
              <statement>
                <command_text>select b_id, b_groupby, b_orderby, b_padding
from (
  select b.groupby b_groupby, 
         b.id b_id, 
         b.orderby b_orderby, 
         b.local_search b_local_search, 
         b.padding b_padding,
         a.id a_id, 
         a.global_search a_global_search
  from TestTable b
  cross join TestTable a
) t
where b_local_search = a_id and 
      a_global_search = 1 and 
      b_groupby = 10
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>10</expected_result_size>
        </test>
        <test>
          <id>109</id>
          <name>CROSS JOIN lateral</name>
          <description>Rewriting join to a cross join lateral.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>110</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.orderby, b.padding
from TestTable a
join TestTable b on b.local_search = a.id
where a.global_search = 1 and b.groupby = 10
</command_text>
              </statement>
            </variant>
            <variant>
              <id>111</id>
              <name>CROSS JOIN lateral</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.orderby, b.padding
from TestTable b
cross apply (
  select global_search 
  from TestTable a 
  where b.local_search = a.id
) a
where a.global_search = 1 and b.groupby = 10
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>10</expected_result_size>
        </test>
        <test>
          <id>112</id>
          <name>Subquery</name>
          <description>This script test the ability to move predicate down in the query tree.
 The second query nest the table join into a subquery which can be easily rewritten into a basic variant.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>113</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.orderby, b.padding
from TestTable a
join TestTable b on b.local_search = a.id
where a.global_search = 1 and b.groupby = 10
</command_text>
              </statement>
            </variant>
            <variant>
              <id>114</id>
              <name>Nesting JOIN in subquery</name>
              <description></description>
              <statement>
                <command_text>select b_id, b_groupby, b_orderby, b_padding
from
(
  select b.groupby b_groupby, 
         b.id b_id, 
         b.orderby b_orderby, 
         b.padding b_padding,
         a.global_search a_global_search
  from TestTable b
  join TestTable a on b.local_search = a.id
) t
where a_global_search = 1 and 
      b_groupby = 10</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>10</expected_result_size>
        </test>
        <test>
          <id>115</id>
          <name>Redundant predicate 1</name>
          <description>This test introduce redundant exists predicate in the second query.
 The EXISTS construct in the second query is covered by the other parts of the query, therefore, it is redundant.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>116</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.orderby, b.padding
from TestTable a
join TestTable b on b.local_search = a.id
where a.global_search = 1 and b.groupby = 10
</command_text>
              </statement>
            </variant>
            <variant>
              <id>117</id>
              <name>Redundant predicate elimination 1</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.orderby, b.padding
from TestTable a
join TestTable b on b.local_search = a.id
where a.global_search = 1 and 
      b.groupby = 10 and
      exists( -- this exists can be eliminated since join and predicate is already part of the outer join
        select 1 
        from TestTable a 
        where a.global_search = 1 and b.local_search = a.id
      )
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>10</expected_result_size>
        </test>
        <test>
          <id>118</id>
          <name>Redundant predicate 2</name>
          <description>This test introduces a redundant predicate that is covered by the other parts of the query.
 More precisely, the `a.global_search = 1` predicate on the same data can be found twice in the second query (once in the subquery and once in the outer query).
</description>
          <active>True</active>
          <variants>
            <variant>
              <id>119</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.orderby, b.padding
from TestTable a
join TestTable b on b.local_search = a.id
where a.global_search = 1 and b.groupby = 10

</command_text>
              </statement>
            </variant>
            <variant>
              <id>120</id>
              <name>Redundant predicate elimination</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.orderby, b.padding
from TestTable b
join (select * from TestTable where global_search = 1) a on b.local_search = a.id
where a.global_search = 1 and -- this predicate can be eliminated since it is covered by the predicate in the subquery
      b.groupby = 10
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>10</expected_result_size>
        </test>
        <test>
          <id>121</id>
          <name>Redundant OUTER JOIN 1</name>
          <description>This test introduces redundant outer join. The outer join is eliminated by the `a.global_search = 1` predicate anyway.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>122</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.orderby, b.padding
from TestTable a
join TestTable b on b.local_search = a.id
where a.global_search = 1 and b.groupby = 10
</command_text>
              </statement>
            </variant>
            <variant>
              <id>123</id>
              <name>Unnecessary LEFT JOIN</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.orderby, b.padding
from TestTable b
left join TestTable a on b.local_search = a.id
where a.global_search = 1 and 
      b.groupby = 10
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>10</expected_result_size>
        </test>
        <test>
          <id>124</id>
          <name>Redundant OUTER JOIN 2</name>
          <description>This test introduces redundant outer join. 
The outer join is eliminated by the `a.id is not null` predicate.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>125</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.orderby, b.padding
from TestTable a
join TestTable b on b.local_search = a.id
where a.global_search = 1 and b.groupby = 10
</command_text>
              </statement>
            </variant>
            <variant>
              <id>126</id>
              <name>Unnecessary LEFT JOIN</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.orderby, b.padding
from TestTable b
left join TestTable a on b.local_search = a.id and 
                        a.global_search = 1
where a.id is not null and b.groupby = 10
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>10</expected_result_size>
        </test>
        <test>
          <id>127</id>
          <name>Aggregate pushdown</name>
          <description>Pushdown the groupby attribute aggregation and using an extra semijoin. 
The semijoin is realized using EXISTS, however, we may use any semijoin syntax that is available in DBMS. 
Semijoin avoids multiplication of the `TestTable.groupby` values. 
The effectivness of this rewritting may be heavily dependent on a number of groupby repetitions and selectivity of the semijoin.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>128</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select distinct b.groupby
from TestTable b
join TestTable a on b.local_search = a.id
where a.global_search = 1
</command_text>
              </statement>
            </variant>
            <variant>
              <id>129</id>
              <name>Aggregation pushdown</name>
              <description></description>
              <statement>
                <command_text>select t.groupby
from 
(
    select distinct groupby from TestTable
) t
where exists
(
    select 1 
    from TestTable a 
    join TestTable b on b.local_search = a.id
    where a.global_search = 1 and b.groupby = t.groupby
)
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>99</expected_result_size>
        </test>
        <test>
          <id>130</id>
          <name>CROSS JOIN lateral</name>
          <description>The second query uses a cross join lateral + aggregation function to implement the semijoin.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>131</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select distinct b.groupby
from TestTable b
join TestTable a on b.local_search = a.id
where a.global_search = 1
</command_text>
              </statement>
            </variant>
            <variant>
              <id>132</id>
              <name>CROSS APPLY</name>
              <description></description>
              <statement>
                <command_text>select distinct b.groupby
from TestTable b
cross apply (
  select count(*) table1_c 
  from TestTable a 
  where b.local_search = a.id and 
        a.global_search = 1
) t
where t.table1_c &gt; 0
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>99</expected_result_size>
        </test>
        <test>
          <id>133</id>
          <name>Redundant subquery</name>
          <description></description>
          <active>True</active>
          <variants>
            <variant>
              <id>134</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where a.global_search IN (SELECT a.global_search FROM TestTable) and
      a.local_search = 1</command_text>
              </statement>
            </variant>
            <variant>
              <id>135</id>
              <name>Predicate rewirte</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where a.global_search IS NOT NULL and 
      a.local_search = 1</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>572</expected_result_size>
        </test>
        <test>
          <id>136</id>
          <name>Independent summaries</name>
          <description>Test compares two basic approaches that can be used to compute summaries.
 The first query compute summarie using subqueries behind SELECT.
 The second query compute summaries using GROUP BY with JOIN.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>137</id>
              <name>Subquery behind SELECT</name>
              <description></description>
              <statement>
                <command_text>select b1.groupby,
     (
        select sum(b2.local_search)
        from TestTable b2
        where b2.groupby = b1.groupby
     ),
     (
        select min(a.id)
        from TestTable b2
        join Table1 a on b2.id = a.local_search
        where b2.groupby = b1.groupby
     ) min_id
from (select distinct groupby from TestTable ) b1
</command_text>
              </statement>
            </variant>
            <variant>
              <id>138</id>
              <name>GROUP BY with JOIN</name>
              <description></description>
              <statement>
                <command_text>select b1.groupby, t1.sum_local_search, t2.min_id
from (select distinct groupby from TestTable ) b1
left join (
    select b2.groupby, sum(b2.local_search) sum_local_search
    from TestTable b2
    group by b2.groupby
) t1 on b1.groupby = t1.groupby
left join (
    select b2.groupby, min(a.id) min_id
    from TestTable b2
    join Table1 a on b2.id = a.global_search
    group by b2.groupby
) t2 on b1.groupby = t2.groupby
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>102</expected_result_size>
        </test>
        <test>
          <id>139</id>
          <name>UNION with JOIN 1</name>
          <description></description>
          <active>True</active>
          <variants>
            <variant>
              <id>140</id>
              <name>UNION in subquery</name>
              <description></description>
              <statement>
                <command_text>select a.id, t.p
from TestTable a
join (
  select local_search c1, padding p
  from TestTable 
  where groupby = 1
  union all
  select groupby c1, padding p
  from TestTable 
  where local_search = 2
) t on a.id = t.c1 and a.global_search = 1
</command_text>
              </statement>
            </variant>
            <variant>
              <id>141</id>
              <name>UNION in outer query</name>
              <description></description>
              <statement>
                <command_text>select a.id, t.padding
from TestTable a
join TestTable t on a.id = t.local_search and 
       a.global_search = 1 and
       t.groupby = 1
union all
select a.id, a.padding
from TestTable a
join TestTable t on a.id = t.groupby and 
       a.global_search = 1 and
       t.local_search = 2
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>199</expected_result_size>
        </test>
        <test>
          <id>142</id>
          <name>UNION with JOIN 2</name>
          <description></description>
          <active>True</active>
          <variants>
            <variant>
              <id>143</id>
              <name>UNION in subquery</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.padding, cnt
from TestTable a
join (
  select local_search c1, count(*) cnt
  from TestTable
  group by local_search
  union all
  select groupby c1, count(*) cnt
  from TestTable
  group by groupby
) t on a.id = t.c1 and a.global_search = 1
</command_text>
              </statement>
            </variant>
            <variant>
              <id>144</id>
              <name>UNION in outer query</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.padding, cnt
from TestTable a
join (
  select local_search c1, count(*) cnt
  from TestTable
  group by local_search
) t on a.id = t.c1 and 
       a.global_search = 1
union all
select a.id, a.padding, cnt
from TestTable a
join (
  select groupby c1, count(*) cnt
  from TestTable
  group by groupby
) t on a.id = t.c1 and 
       a.global_search = 1
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>2</expected_result_size>
        </test>
      </tests>
      <configurations>
        <configuration>
          <id>145</id>
          <name>Heap</name>
          <description></description>
          <init_script>
            <statements />
          </init_script>
          <clean_up_script>
            <statements />
          </clean_up_script>
        </configuration>
        <configuration>
          <id>146</id>
          <name>Non-clustered 1</name>
          <description></description>
          <init_script>
            <statements>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_ls_groupby
ON TestTable (local_search, groupby)
</command_text>
              </statement>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_gs_id
ON TestTable (global_search,id)
</command_text>
              </statement>
            </statements>
          </init_script>
          <clean_up_script>
            <statements>
              <statement>
                <command_text>drop index ix_TestTable_ls_groupby
</command_text>
              </statement>
              <statement>
                <command_text>drop index ix_TestTable_gs_id</command_text>
              </statement>
            </statements>
          </clean_up_script>
        </configuration>
        <configuration>
          <id>147</id>
          <name>Non-clustered 2</name>
          <description></description>
          <init_script>
            <statements>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_groupby_ls
ON TestTable (groupby, local_search)
</command_text>
              </statement>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_gs_id
ON TestTable (global_search,id)</command_text>
              </statement>
            </statements>
          </init_script>
          <clean_up_script>
            <statements>
              <statement>
                <command_text>drop index ix_TestTable_groupby_ls
</command_text>
              </statement>
              <statement>
                <command_text>drop index ix_TestTable_gs_id</command_text>
              </statement>
            </statements>
          </clean_up_script>
        </configuration>
        <configuration>
          <id>148</id>
          <name>Non-clustered 3</name>
          <description></description>
          <init_script>
            <statements>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_ls_groupby
ON TestTable (local_search, groupby)
</command_text>
              </statement>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_id_gs
ON TestTable (id, global_search)</command_text>
              </statement>
            </statements>
          </init_script>
          <clean_up_script>
            <statements>
              <statement>
                <command_text>drop index ix_TestTable_ls_groupby
</command_text>
              </statement>
              <statement>
                <command_text>drop index ix_TestTable_id_gs</command_text>
              </statement>
            </statements>
          </clean_up_script>
        </configuration>
        <configuration>
          <id>149</id>
          <name>Non-clustered 4</name>
          <description></description>
          <init_script>
            <statements>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_groupby_ls
ON TestTable (groupby, local_search)
</command_text>
              </statement>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_id_gs
ON TestTable (id, global_search)</command_text>
              </statement>
            </statements>
          </init_script>
          <clean_up_script>
            <statements>
              <statement>
                <command_text>drop index ix_TestTable_groupby_ls
</command_text>
              </statement>
              <statement>
                <command_text>drop index ix_TestTable_id_gs</command_text>
              </statement>
            </statements>
          </clean_up_script>
        </configuration>
        <configuration>
          <id>150</id>
          <name>Non-clustered 5</name>
          <description></description>
          <init_script>
            <statements>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_groupby
ON TestTable (groupby)
</command_text>
              </statement>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_ls
ON TestTable (local_search)
</command_text>
              </statement>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_id
ON TestTable (id)
</command_text>
              </statement>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_gs
ON TestTable (global_search)</command_text>
              </statement>
            </statements>
          </init_script>
          <clean_up_script>
            <statements>
              <statement>
                <command_text>drop index ix_TestTable_groupby
</command_text>
              </statement>
              <statement>
                <command_text>drop index ix_TestTable_ls
</command_text>
              </statement>
              <statement>
                <command_text>drop index ix_TestTable_id
</command_text>
              </statement>
              <statement>
                <command_text>drop index ix_TestTable_gs</command_text>
              </statement>
            </statements>
          </clean_up_script>
        </configuration>
      </configurations>
    </test_group>
    <test_group>
      <id>151</id>
      <name>04 PK</name>
      <description></description>
      <tests>
        <test>
          <id>152</id>
          <name>Aggregation removal 1</name>
          <description>Test of possible aggreagation removal. 
The aggregation can be rewritten to distinct without aggregation function if the `TestTable.local_search` attribute is functionaly dependent on `TestTable.id`.
 The `TestTable.id` attribute is the primary key in this test, therefore, the functional dependency is satisfied.
</description>
          <active>True</active>
          <variants>
            <variant>
              <id>153</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select b.id, max(b.local_search)
from TestTable b
where b.id &lt; 100
group by b.id
</command_text>
              </statement>
            </variant>
            <variant>
              <id>154</id>
              <name>Aggregation removal</name>
              <description></description>
              <statement>
                <command_text>select distinct b.id, b.local_search
from TestTable b
where b.id &lt; 100
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>100</expected_result_size>
        </test>
        <test>
          <id>155</id>
          <name>Aggregation removal 2</name>
          <description>Test of possible aggregation removal. 
The aggregation can be rewritten to distinct without aggregation function if the `local_search` attribute is functionaly dependent on id.
 In our test `TestTable.id` is primary key.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>156</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select min(min_local_search)
from
(
    select max(local_search) min_local_search
    from TestTable
    group by id
) t
</command_text>
              </statement>
            </variant>
            <variant>
              <id>157</id>
              <name>Aggregation removal</name>
              <description></description>
              <statement>
                <command_text>select min(local_search)
from
(
    select local_search
    from TestTable
) t
</command_text>
              </statement>
            </variant>
            <variant>
              <id>158</id>
              <name>Nested query removal</name>
              <description></description>
              <statement>
                <command_text>select min(local_search)
from TestTable
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>1</expected_result_size>
        </test>
        <test>
          <id>159</id>
          <name>Predicate elimination 1</name>
          <description>Test of `IS NOT NULL` predicate elimination. 
The `IS NOT NULL` predicate can be eliminated since the `id` is a primary key, therefore, it can not be null.
</description>
          <active>True</active>
          <variants>
            <variant>
              <id>160</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where a.id IS NOT NULL and
      a.local_search = 5000
</command_text>
              </statement>
            </variant>
            <variant>
              <id>161</id>
              <name>Predicate elimination</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where a.id IS NOT NULL and
      a.local_search = 5000
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>50</expected_result_size>
        </test>
        <test>
          <id>162</id>
          <name>Predicate elimination 2</name>
          <description>Test of a IS NOT NULL predicate elimination. 
The `TestTable.id` attribute can not be null since it is the primary key.
-- Therefore, the `IS NOT NULL` predicate can be eliminated.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>163</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where a.id IS NOT NULL and
      a.local_search = 1
</command_text>
              </statement>
            </variant>
            <variant>
              <id>164</id>
              <name>Predicate elimination</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.local_search, a.padding
from TestTable a 
where a.local_search = 1
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>572</expected_result_size>
        </test>
        <test>
          <id>165</id>
          <name>Aggregation removal</name>
          <description>Test of an aggregation removal. The aggregation can be rewritten using `distinct` without aggregation function 
if the `TestTable.local_search` attribute is functionaly dependent on the `TestTable.id` attribute which is satisfied in this test.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>166</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select b.id, min(b.local_search)
from TestTable b
where b.local_search = 5000
group by b.id</command_text>
              </statement>
            </variant>
            <variant>
              <id>167</id>
              <name>Aggregation removal</name>
              <description></description>
              <statement>
                <command_text>select distinct b.id, b.local_search
from TestTable b
where b.local_search = 5000</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>50</expected_result_size>
        </test>
      </tests>
      <configurations>
        <configuration>
          <id>168</id>
          <name>Heap</name>
          <description></description>
          <init_script>
            <statements>
              <statement>
                <command_text>alter table TestTable add constraint pk_TestTable_id primary key (id);</command_text>
              </statement>
            </statements>
          </init_script>
          <clean_up_script>
            <statements>
              <statement>
                <command_text>alter table TestTable drop constraint pk_TestTable_id</command_text>
              </statement>
            </statements>
          </clean_up_script>
        </configuration>
        <configuration>
          <id>169</id>
          <name>Non-clustered index</name>
          <description></description>
          <init_script>
            <statements>
              <statement>
                <command_text>alter table TestTable add constraint pk_TestTable_id primary key (id);
</command_text>
              </statement>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_ls
ON TestTable (local_search)</command_text>
              </statement>
            </statements>
          </init_script>
          <clean_up_script>
            <statements>
              <statement>
                <command_text>drop index ix_TestTable_ls
</command_text>
              </statement>
              <statement>
                <command_text>alter table TestTable drop constraint pk_TestTable_id
</command_text>
              </statement>
            </statements>
          </clean_up_script>
        </configuration>
      </configurations>
    </test_group>
    <test_group>
      <id>170</id>
      <name>05 PK</name>
      <description></description>
      <tests>
        <test>
          <id>183</id>
          <name>Semi-join</name>
          <description>Using a semijoin instead of join. We can use a semijoin if the `Table1.id` attribute is the primary key.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>184</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.orderby, b.padding
from TestTable b
join TestTable a on b.local_search = a.id
where a.global_search = 1 and b.groupby = 10
</command_text>
              </statement>
            </variant>
            <variant>
              <id>185</id>
              <name>Semi-join</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.orderby, b.padding
from TestTable b
where exists( 
        select 1 
        from TestTable a 
        where global_search = 1 and b.local_search = a.id
    ) and
    b.groupby = 10
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>10</expected_result_size>
        </test>
        <test>
          <id>186</id>
          <name>Redundant JOIN elimination</name>
          <description>Introducing redundant join into a simple SQL.
The last join in the second query is redundant since the following is true:
1. The `TestTable.id` attribute is unique. (therefore it is not possible to multiply the resut adding the join)
2. The `m2.id` attribute is the only attribute of m2 used in the query.
3. The identical join is already in query.
</description>
          <active>True</active>
          <variants>
            <variant>
              <id>187</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.orderby, b.padding
from TestTable b
join TestTable a on b.local_search = a.id
where a.global_search = 1 and b.groupby = 10
</command_text>
              </statement>
            </variant>
            <variant>
              <id>188</id>
              <name>Reundant join 1</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.orderby, b.padding
from TestTable b
join TestTable m1 on b.local_search = m1.id
join TestTable m2 on b.local_search = m2.id -- this join can be eliminated if the Table1.id attribute is the primary key
where m1.global_search = 1 and b.groupby = 10
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>10</expected_result_size>
        </test>
        <test>
          <id>189</id>
          <name>Predicate rewrite</name>
          <description>Simple rewrite of the query predicates may sometimes lead to unexpected behaviour.
low-or-equal predicates are handled differently during the query optimization.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>190</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.orderby, b.padding
from TestTable b
join TestTable a on b.local_search = a.id
where a.global_search = 1 and b.groupby = 10
</command_text>
              </statement>
            </variant>
            <variant>
              <id>191</id>
              <name>Predicate rewrite</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.orderby, b.padding
from TestTable b
join TestTable a on b.local_search = a.id
where a.global_search = 1 and b.groupby &gt; 9 and b.groupby &lt; 11 
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>10</expected_result_size>
        </test>
        <test>
          <id>192</id>
          <name>Redundant subquery elimination</name>
          <description>Introducing redundant self-join in a subquery instead regular column projection
The rewrite is possible due to the following reasons:
1. The subquery access the superset relation when compared the outer relation. 
2. The correlated join is according to the primary key (the join can not multiply).
</description>
          <active>True</active>
          <variants>
            <variant>
              <id>193</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.orderby, b.padding
from TestTable b
where b.local_search = 5000
</command_text>
              </statement>
            </variant>
            <variant>
              <id>194</id>
              <name>Redundant subquery</name>
              <description></description>
              <statement>
                <command_text>select b1.id, b1.groupby, b1.orderby, (
         select b2.padding
         from TestTable b2
         where b1.id = b2.id -- this subquery can be eliminated if the TestTable.id attribute is the primary key
       )
from TestTable b1
where b1.local_search = 5000
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>50</expected_result_size>
        </test>
        <test>
          <id>195</id>
          <name>Aggregate pushdown</name>
          <description>Pushdown the `groupby` attribute aggregation. 
Since the `TestTable.id` attribute is a primary key the join can not multiply the `TestTable.groupby` values.
Therefore, it is safe to perform the distinct first and then the join.
This optimization is described in "Chaudhuri, Surajit. "An overview of query optimization in relational systems." Proceedings of the seventeenth ACM SIGACT-SIGMOD-SIGART symposium on Principles of database systems. ACM, 1998."</description>
          <active>True</active>
          <variants>
            <variant>
              <id>196</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select distinct b.local_search
from TestTable b
join TestTable a on b.local_search = a.id
where a.global_search &lt; 10
</command_text>
              </statement>
            </variant>
            <variant>
              <id>197</id>
              <name>Aggregation pushdown</name>
              <description></description>
              <statement>
                <command_text>select b.local_search
from 
(
    select distinct local_search from TestTable
) b
join TestTable a on b.local_search = a.id
where a.global_search &lt; 10
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>10</expected_result_size>
        </test>
        <test>
          <id>198</id>
          <name>Attribute removal</name>
          <description>Test of possible attribute removal from a GROUP BY attribute list.
The `TestTable.global_search` attribute can be removed from the aggregation if the `TestTable.id` attribute is a primary key.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>199</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select a.id, a.global_search, count(*)
from TestTable a
join TestTable b on a.id = b.local_search
where a.global_search &lt; 10
group by a.id, a.global_search
</command_text>
              </statement>
            </variant>
            <variant>
              <id>200</id>
              <name>Removal from GROUP BY</name>
              <description></description>
              <statement>
                <command_text>select a.id, min(a.global_search), count(*)
from TestTable a
join TestTable b on a.id = b.local_search
where a.global_search &lt; 10
group by a.id
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>10</expected_result_size>
        </test>
        <test>
          <id>201</id>
          <name>Join merge</name>
          <description>Merge of two joins into one.
The merge of joins is possible:
1. If `TestTable.id` is a primary key,
2. joins are using the same table and the same join condition,
3. we are not using attributes from `TestTable` in the SQL output,
4. we perform group by according to the attribute in the join.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>202</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.orderby, b.padding
from TestTable b
join TestTable m1 on b.id = m1.local_search and m1.groupby = 20 
join TestTable m2 on b.id = m2.local_search and m2.groupby = 10
where b.global_search = 1
group by b.id, b.groupby, b.orderby, b.padding 
</command_text>
              </statement>
            </variant>
            <variant>
              <id>203</id>
              <name>Join merge</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.orderby, b.padding
from TestTable b
join TestTable m1 on b.id = m1.local_search and 
                 (m1.groupby = 10 or m1.groupby = 20)
where b.global_search = 1
group by b.id, b.groupby, b.orderby, b.padding 
having count(distinct m1.groupby) = 2
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>1</expected_result_size>
        </test>
        <test>
          <id>204</id>
          <name>Redundant JOIN</name>
          <description>The second query contains an extra join.
If the `TestTable.id` attribute is a primary key.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>205</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.local_search, b.padding
from TestTable b
join TestTable a on b.local_search = a.id
where a.global_search = 1 and b.groupby &lt; 2
</command_text>
              </statement>
            </variant>
            <variant>
              <id>206</id>
              <name>Extra JOIN</name>
              <description></description>
              <statement>
                <command_text>select b.id, b.groupby, b.local_search, r.padding
from TestTable b
join TestTable a on b.local_search = a.id
join TestTable r on r.id = b.id
where a.global_search = 1 and b.groupby &lt; 2
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>100</expected_result_size>
        </test>
      </tests>
      <configurations>
        <configuration>
          <id>171</id>
          <name>Heap</name>
          <description></description>
          <init_script>
            <statements>
              <statement>
                <command_text>alter table TestTable add constraint pk_TestTable_id primary key (id)</command_text>
              </statement>
            </statements>
          </init_script>
          <clean_up_script>
            <statements>
              <statement>
                <command_text>alter table TestTable drop constraint pk_TestTable_id</command_text>
              </statement>
            </statements>
          </clean_up_script>
        </configuration>
        <configuration>
          <id>172</id>
          <name>Non-clustered 1</name>
          <description></description>
          <init_script>
            <statements>
              <statement>
                <command_text>alter table TestTable add constraint pk_TestTable_id primary key (id)
</command_text>
              </statement>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_ls_groupby
ON TestTable (local_search, groupby)
</command_text>
              </statement>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_gs
ON TestTable (global_search)
</command_text>
              </statement>
            </statements>
          </init_script>
          <clean_up_script>
            <statements>
              <statement>
                <command_text>drop index ix_TestTable_ls_groupby
</command_text>
              </statement>
              <statement>
                <command_text>drop index ix_TestTable_gs
</command_text>
              </statement>
              <statement>
                <command_text>alter table TestTable drop constraint pk_TestTable_id</command_text>
              </statement>
            </statements>
          </clean_up_script>
        </configuration>
        <configuration>
          <id>173</id>
          <name>Non-clustered 2</name>
          <description></description>
          <init_script>
            <statements>
              <statement>
                <command_text>alter table TestTable add constraint pk_TestTable_id primary key (id)
</command_text>
              </statement>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_groupby_ls
ON TestTable (groupby, local_search)
</command_text>
              </statement>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_gs
ON TestTable (global_search)</command_text>
              </statement>
            </statements>
          </init_script>
          <clean_up_script>
            <statements>
              <statement>
                <command_text>drop index ix_TestTable_groupby_ls
</command_text>
              </statement>
              <statement>
                <command_text>drop index ix_TestTable_gs
</command_text>
              </statement>
              <statement>
                <command_text>alter table TestTable drop constraint pk_TestTable_id</command_text>
              </statement>
            </statements>
          </clean_up_script>
        </configuration>
      </configurations>
    </test_group>
    <test_group>
      <id>208</id>
      <name>06 PK FK</name>
      <description></description>
      <tests>
        <test>
          <id>211</id>
          <name>JOIN elimination 1</name>
          <description>The join and TestTable with alias `b` can be eliminated due to the following:
1. The `TestTable.id` attribute is the primary key,
2. the `TestTable.local_search` attribute is the foreign key,
3. we are not interested about any attribute values of `b` (in other words `b` is accessed only as a part of the join condition).
Due to this, every row in `a` has to have exactly one row in `b`. 
In other words, the join neither reduce nor expand the rows of `a`, therefore, we can avoid it.
Using the join we just eliminate rows from `a` having null value in the `TestTable.local_search` attribute which can be simply replaced by the `a.local_search is not null` condition.
</description>
          <active>True</active>
          <variants>
            <variant>
              <id>216</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select sum(a.local_search)
from TestTable a 
join TestTable b on b.id = a.local_search
</command_text>
              </statement>
            </variant>
            <variant>
              <id>217</id>
              <name>JOIN elimination</name>
              <description></description>
              <statement>
                <command_text>select sum(a.local_search)
from TestTable a 
where a.local_search is not null
</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>1</expected_result_size>
        </test>
        <test>
          <id>212</id>
          <name>JOIN elimination 2</name>
          <description>he join and TestTable with alias `b` can be eliminated due to the following:
1. The `TestTable.id` attribute is primary key,
2. the `TestTable.local_search` attribute is foreign key,
3. we are not interested about any attribute values of `b` except `b.id`, however, `b.id` is part of the join condition.
Due to this, every row in `a` has to have exactly one row in `b`. 
In other words, the join neither reduce nor expand the rows of `a`, therefore, we can avoid it.
Using the join we just eliminate rows from `a` having null value in the `TestTable.local_search` attribute 
which can be simply replaced by `a.local_search is not null` condition.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>218</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select sum(b.id)
from TestTable a 
join TestTable b on b.id = a.local_search
where b.id &lt; 1000</command_text>
              </statement>
            </variant>
            <variant>
              <id>219</id>
              <name>JOIN elimination</name>
              <description></description>
              <statement>
                <command_text>select sum(a.local_search)
from TestTable a 
where a.local_search &lt; 1000</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>1</expected_result_size>
        </test>
        <test>
          <id>213</id>
          <name>JOIN elimination 3</name>
          <description>The join and TestTable with alias `c` in subquery can be eliminated due to the following:
1. The `TestTable.id` attribute is primary key,
2. the `TestTable.local_search` attribute is foreign key,
3. we are not interested about any attribute values of `c` except `c.id`, however, `c.id` is part of the join condition.
Due to this, every row in `a` has to have exactly one row in `b`. 
In other words, the join neither reduce nor expand the rows of `a`, therefore, we can avoid it.
Using the join we just eliminate rows from `b` having null value in the `TestTable.local_search` attribute which can be simply replaced by `b.local_search is not null` condition.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>220</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select a.id,
  (
    select sum(b.local_search)
    from TestTable b
    join TestTable c on c.id = b.local_search
    where c.id = a.id
  )
from TestTable a
where a.id &lt; 50</command_text>
              </statement>
            </variant>
            <variant>
              <id>221</id>
              <name>JOIN elimination</name>
              <description></description>
              <statement>
                <command_text>select a.id,
  (
    select sum(b.local_search)
    from TestTable b
    where a.id = b.local_search and b.local_search is not null
  )
from TestTable a
where a.id &lt; 50</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>50</expected_result_size>
        </test>
        <test>
          <id>214</id>
          <name>Subquery rewrite</name>
          <description>This test use straightforward rewriting of the subquery behind SELECT into a solution using a JOIN. 
This rewrite does not require the primary key and the foreign key integrity constraints.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>222</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select a.id,
  (
    select sum(b.local_search)
    from TestTable b
    where a.id = b.local_search
  )
from TestTable a
where a.id &lt; 50</command_text>
              </statement>
            </variant>
            <variant>
              <id>223</id>
              <name>Rewrite using JOIN and GROUP BY</name>
              <description></description>
              <statement>
                <command_text>select a.id, b.sum_local_search
from TestTable a
left join (
    select local_search, sum(local_search) sum_local_search
    from TestTable
    group by local_search
) b on a.id = b.local_search
where a.id &lt; 50</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>50</expected_result_size>
        </test>
        <test>
          <id>215</id>
          <name>JOIN elimination 4</name>
          <description>We can eliminate the join due to the following reasons:
1. The `TestTable.id` attribute is primary key,
2. the `TestTable.local_search` attribute is foreign key referencing the `TestTable.id` attribute.
3. we are not interested about any attribute values of `a` except `a.id`, however, `a.id` is part of the join condition.
Due to this, every row in `b` has to have exactly one row in `a`. 
In other words, the join neither reduce nor expand the rows of `b`, therefore, we can avoid it.
Using the join we just eliminate rows from `b` having null value in the `TestTable.local_search` attribute which can be simply replaced by `b.local_search is not null` condition.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>224</id>
              <name>Basic</name>
              <description></description>
              <statement>
                <command_text>select a.id, b.sum_local_search
from TestTable a
join (
    select local_search, sum(local_search) sum_local_search
    from TestTable
    group by local_search
) b on a.id = b.local_search
where a.id &lt; 50</command_text>
              </statement>
            </variant>
            <variant>
              <id>225</id>
              <name>JOIN elimination</name>
              <description></description>
              <statement>
                <command_text>select b.local_search, b.sum_local_search
from (
    select local_search, sum(local_search) sum_local_search
    from TestTable
    group by local_search
) b 
where b.local_search &lt; 50 and b.local_search is not null</command_text>
              </statement>
            </variant>
          </variants>
          <expected_result_size>50</expected_result_size>
        </test>
      </tests>
      <configurations>
        <configuration>
          <id>209</id>
          <name>Heap</name>
          <description></description>
          <init_script>
            <statements>
              <statement>
                <command_text>alter table TestTable add constraint pk_TestTable_id primary key (id)</command_text>
              </statement>
              <statement>
                <command_text>alter table TestTable add constraint fk_TestTable_localsearch 
                      foreign key (local_search) references TestTable(id)
</command_text>
              </statement>
            </statements>
          </init_script>
          <clean_up_script>
            <statements>
              <statement>
                <command_text>alter table TestTable drop constraint fk_TestTable_localsearch</command_text>
              </statement>
              <statement>
                <command_text>alter table TestTable drop constraint pk_TestTable_id</command_text>
              </statement>
            </statements>
          </clean_up_script>
        </configuration>
        <configuration>
          <id>210</id>
          <name>Non-clustered 1</name>
          <description></description>
          <init_script>
            <statements>
              <statement>
                <command_text>alter table TestTable add constraint pk_TestTable_id primary key (id)</command_text>
              </statement>
              <statement>
                <command_text>alter table TestTable add constraint fk_TestTable_localsearch foreign key (local_search) references TestTable(id)
</command_text>
              </statement>
              <statement>
                <command_text>CREATE INDEX ix_TestTable_ls
ON TestTable (local_search)</command_text>
              </statement>
            </statements>
          </init_script>
          <clean_up_script>
            <statements>
              <statement>
                <command_text>alter table TestTable drop constraint fk_TestTable_localsearch</command_text>
              </statement>
              <statement>
                <command_text>alter table TestTable drop constraint pk_TestTable_id</command_text>
              </statement>
              <statement>
                <command_text>drop index ix_TestTable_ls</command_text>
              </statement>
            </statements>
          </clean_up_script>
        </configuration>
      </configurations>
    </test_group>
  </test_groups>
  <connection_settings>
    <provider>PostgreSQL</provider>
    <settings use_connection_string="false" host="dbsys.cs.vsb.cz" user_name="luk194" password="PyUqkO9Yzb" database="luk194" command_timeout="60" connection_string="" />
  </connection_settings>
  <test_runs />
  <last_id>265</last_id>
</sql_benchmark>