<?xml version="1.0" encoding="utf-8"?>
<sql_benchmark>
  <name>SQL Benchmark 1</name>
  <author></author>
  <description>Query rewriting benchmark</description>
  <init_script>
    <default_statement_list>
      <statements />
    </default_statement_list>
    <specific_statement_lists>
      <specific_statement_list>
        <provider_name>Microsoft SQL Server</provider_name>
        <statements>
          <statement>
            <command_text>--Drop tables if exists A
--Drop tables if exists B
IF OBJECT_ID('dbo.A', 'U') IS NOT NULL DROP TABLE dbo.A
IF OBJECT_ID('dbo.B', 'U') IS NOT NULL DROP TABLE dbo.B
IF OBJECT_ID('dbo.AB', 'U') IS NOT NULL DROP TABLE dbo.AB</command_text>
          </statement>
          <statement>
            <command_text>--Create table A (id int, groupby int, orderby int, fkb int, search int, padding varchar())
WITH x AS 
(
  SELECT n FROM (VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) v(n)
), t1 AS
(
  SELECT ones.n + 10 * tens.n + 100 * hundreds.n + 1000 * thousands.n + 10000 * tenthousands.n  + 100000 * hundredthousands.n as id  
  FROM x ones,     x tens,      x hundreds,       x thousands,       x tenthousands ,       x hundredthousands
), t2 AS
(
    SELECT  id,
            id % 100 groupby
    FROM t1
), t3 AS
(
    SELECT  b.id, 
            b.groupby, 
            row_number() over (partition by groupby order by id) orderby
    FROM t2 b
)
SELECT  cast(id as int) id, 
        cast(groupby as int) groupby, 
        cast(orderby as int) orderby,
        cast((id * floor((id+500)/500)) % 9173 as int) fkb, 
        cast (id % 911 as int) search, 
        LEFT('Value ' + CAST(id AS VARCHAR) + ' ' + REPLICATE('*', 1000), 1000) as padding
    INTO A
FROM t3
</command_text>
          </statement>
          <statement>
            <command_text>--Create table B (id int, groupby int, padding varchar())
WITH x AS 
(
  SELECT n FROM (VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) v(n)
), t1 AS
(
  SELECT ones.n + 10 * tens.n + 100 * hundreds.n + 1000 * thousands.n as id  
  FROM x ones,     x tens,      x hundreds,       x thousands       
)
SELECT  cast(id as int) id,
        cast((id + floor(100000 / (id+1))) % 100 as int) groupby,
        cast(id % 901 as int) search, 
        cast((id * floor((id+500)/500)) % 9173 as int) fka, 
        LEFT('Value ' + CAST(id AS VARCHAR) + ' ' + REPLICATE('*', 1000), 1000) as padding
INTO B
FROM t1
</command_text>
          </statement>
          <statement>
            <command_text>--Create table AB (fkb int, fkb int)
WITH x AS 
(
  SELECT n FROM (VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9)) v(n)
), t1 AS
(
  SELECT ones.n + 10 * tens.n + 100 * hundreds.n + 1000 * thousands.n + 10000 * tenthousands.n  + 100000 * hundredthousands.n as id  
  FROM x ones,     x tens,      x hundreds,       x thousands,       x tenthousands ,       x hundredthousands
)
SELECT  distinct cast(sqrt(id) as int) fkb,
        cast((id * floor((id+500)/500)) % 9173 as int) fka
INTO AB
FROM t1


--insert of some outlier data
insert into A(id, groupby, orderby, fkb, search, padding) values (1000000, null, null, null, null, '*');
insert into A(id, groupby, orderby, fkb, search, padding) values (1000001, 100, null, null, null, '*');
insert into A(id, groupby, orderby, fkb, search, padding) values (1000002, 99, 10000, null, null, '*');
insert into A(id, groupby, orderby, fkb, search, padding) values (1000003, 101, 10000, 1, null, '*');
insert into A(id, groupby, orderby, fkb, search, padding) values (1000004, null, null, 1, null, '*');
insert into A(id, groupby, orderby, fkb, search, padding) values (1000005, null, null, 500, null, '*');
insert into A(id, groupby, orderby, fkb, search, padding) values (1000006, null, null, 1, 1, '*');
insert into A(id, groupby, orderby, fkb, search, padding) values (1000007, null, null, null, 1, '*');
</command_text>
          </statement>
          <statement>
            <command_text>insert into B(id, groupby, search, padding) values (10000, null, null, null);
insert into B(id, groupby, search, padding) values (10001, null, 1, null);
insert into B(id, groupby, search, padding) values (10002, 1, null, null);
insert into B(id, groupby, search, padding) values (10003, 1, 1, null);
</command_text>
          </statement>
          <statement>
            <command_text>--Set id of both tables as a primary key
alter table A alter column id int not null;
alter table B alter column id int not null;
alter table AB alter column fka int not null;
alter table AB alter column fkb int not null;</command_text>
          </statement>
          <statement>
            <command_text>alter table A add constraint pk_a_id primary key (id);
alter table B add constraint pk_b_id primary key (id);
alter table AB add constraint pk_ab_fka_fkb primary key (fka, fkb);

</command_text>
          </statement>
        </statements>
      </specific_statement_list>
      <specific_statement_list>
        <provider_name>Oracle Database</provider_name>
        <statements>
          <statement>
            <command_text>BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE A';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;
</command_text>
          </statement>
          <statement>
            <command_text> 
BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE B';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;
 </command_text>
          </statement>
          <statement>
            <command_text> 
--Create table A (id int, groupby int, orderby int, fkb int, search int, padding varchar())
CREATE  TABLE A AS
WITH x AS 
(
  SELECT 0 n FROM dual
  union all 
  SELECT 1 FROM dual
  union all 
  SELECT 2 FROM dual
  union all 
  SELECT 3 FROM dual
  union all 
  SELECT 4 FROM dual
  union all 
  SELECT 5 FROM dual
  union all 
  SELECT 6 FROM dual
  union all 
  SELECT 7 FROM dual
  union all 
  SELECT 8 FROM dual
  union all 
  SELECT 9 FROM dual  
), t1 AS
(
  SELECT ones.n + 10 * tens.n + 100 * hundreds.n + 1000 * thousands.n + 10000 * tenthousands.n + 100000 * hundredthousands.n as id  
  FROM x ones,     x tens,      x hundreds,       x thousands,       x tenthousands,       x hundredthousands
), t2 AS
(
    SELECT  id,
            mod(id, 100) groupby
    FROM t1
), t3 AS
(
    SELECT  b.id, b.groupby, row_number() over (partition by groupby order by id) orderby
    FROM t2 b
)
SELECT  cast(id as int) id, 
        cast(groupby as int) groupby, 
        cast(orderby as int) orderby,
        cast(mod(orderby, 9173) as int) fkb, 
        cast(mod(id, 911) as int) search, 
        RPAD(concat('Value ', id), 1000, '*') as padding   
FROM t3;
</command_text>
          </statement>
          <statement>
            <command_text>--Create table B (id int, groupby int, search int, padding varchar())
CREATE  TABLE B AS
WITH x AS 
(
  SELECT 0 n FROM dual
  union all 
  SELECT 1 FROM dual
  union all 
  SELECT 2 FROM dual
  union all 
  SELECT 3 FROM dual
  union all 
  SELECT 4 FROM dual
  union all 
  SELECT 5 FROM dual
  union all 
  SELECT 6 FROM dual
  union all 
  SELECT 7 FROM dual
  union all 
  SELECT 8 FROM dual
  union all 
  SELECT 9 FROM dual  
), t1 AS
(
  SELECT ones.n + 10 * tens.n + 100 * hundreds.n + 1000 * thousands.n as id  
  FROM x ones,     x tens,      x hundreds,       x thousands       
)
SELECT  cast(id as int) id,
        cast(mod(id + floor(100000 / (id+1)) , 100) as int) groupby,
        cast (mod(id, 901) as int) search, 
        RPAD(concat('Value ', id), 1000, '*') as padding  
FROM t1;
</command_text>
          </statement>
          <statement>
            <command_text>--insert of some outlier data
insert into A(id, groupby, orderby, fkb, search, padding) values (1000000, null, null, null, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000001, 100, null, null, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000002, 99, 10000, null, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000003, 101, 10000, 1, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000004, null, null, 1, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000005, null, null, 500, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000006, null, null, 1, 1, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000007, null, null, null, 1, '*');
</command_text>
          </statement>
          <statement>
            <command_text>insert into B(id, groupby, search, padding) values (10000, null, null, null);</command_text>
          </statement>
          <statement>
            <command_text>insert into B(id, groupby, search, padding) values (10001, null, 1, null);</command_text>
          </statement>
          <statement>
            <command_text>insert into B(id, groupby, search, padding) values (10002, 1, null, null);</command_text>
          </statement>
          <statement>
            <command_text>insert into B(id, groupby, search, padding) values (10003, 1, 1, null);
</command_text>
          </statement>
          <statement>
            <command_text>--Set id of both tables as a primary key
alter table A modify id int not null;</command_text>
          </statement>
          <statement>
            <command_text>alter table B modify id int not null;
</command_text>
          </statement>
          <statement>
            <command_text>alter table A add constraint pk_a_id primary key (id);</command_text>
          </statement>
          <statement>
            <command_text>alter table B add constraint pk_b_id primary key (id);
</command_text>
          </statement>
        </statements>
      </specific_statement_list>
      <specific_statement_list>
        <provider_name>PostgreSQL</provider_name>
        <statements>
          <statement>
            <command_text>DROP TABLE IF EXISTS A CASCADE;
DROP TABLE IF EXISTS B CASCADE;
</command_text>
          </statement>
          <statement>
            <command_text>CREATE TABLE A (
    id int,
    groupby int,
    orderby int,
    fkb int,
    search int,
    padding varchar(1000)
);


CREATE TABLE B (
    id int,
    groupby int,
    search int,
    fka int,
    padding varchar(1000)
);
</command_text>
          </statement>
          <statement>
            <command_text>INSERT
INTO    A
WITH t1 AS
(
  SELECT id
  FROM generate_series(0, 999999) id
), t2 AS
(
    SELECT  id,
            id % 100 groupby
    FROM t1
), t3 AS
(
    SELECT  b.id,
            b.groupby,
            row_number() over (partition by groupby order by id) orderby
    FROM t2 b
)
SELECT  id,
        groupby,
        orderby orderby,
        cast(cast(id * floor((id+500)/500) as int) % 9173 as int) fkb,
        cast (id % 911 as int) lsearch,
        RPAD('Value ' || id || ' ' , 1000, '*') as padding
FROM t3;
</command_text>
          </statement>
          <statement>
            <command_text>INSERT
INTO    B
SELECT  cast(id as int) id,
        cast((id + floor(100000 / (id+1))) as int) % 100 groupby,
        cast (id % 901 as int) lsearch,
        cast((id * floor((id+500)/500)) % 9173 as int) fka, 
        RPAD('Value ' || id || ' ' , 1000, '*') as padding
FROM generate_series(0, 9999) id;
</command_text>
          </statement>
          <statement>
            <command_text>--insert of some outlier data
insert into A(id, groupby, orderby, fkb, search, padding) values (1000000, null, null, null, null, '*');
insert into A(id, groupby, orderby, fkb, search, padding) values (1000001, 100, null, null, null, '*');
insert into A(id, groupby, orderby, fkb, search, padding) values (1000002, 99, 10000, null, null, '*');
insert into A(id, groupby, orderby, fkb, search, padding) values (1000003, 101, 10000, 1, null, '*');
insert into A(id, groupby, orderby, fkb, search, padding) values (1000004, null, null, 1, null, '*');
insert into A(id, groupby, orderby, fkb, search, padding) values (1000005, null, null, 500, null, '*');
insert into A(id, groupby, orderby, fkb, search, padding) values (1000006, null, null, 1, 1, '*');
insert into A(id, groupby, orderby, fkb, search, padding) values (1000007, null, null, null, 1, '*');
</command_text>
          </statement>
          <statement>
            <command_text>insert into B(id, groupby, search, padding) values (10000, null, null, null);
insert into B(id, groupby, search, padding) values (10001, null, 1, null);
insert into B(id, groupby, search, padding) values (10002, 1, null, null);
insert into B(id, groupby, search, padding) values (10003, 1, 1, null);
</command_text>
          </statement>
          <statement>
            <command_text>--Set id of both tables as a primary key
alter table A alter column id set not null;
alter table B alter column id set not null;
</command_text>
          </statement>
          <statement>
            <command_text>alter table A add constraint pk_a_id primary key (id);
alter table B add constraint pk_b_id primary key (id);</command_text>
          </statement>
        </statements>
      </specific_statement_list>
      <specific_statement_list>
        <provider_name>MySQL</provider_name>
        <statements>
          <statement>
            <command_text>DROP TABLE IF EXISTS A;
</command_text>
          </statement>
          <statement>
            <command_text> 
DROP TABLE IF EXISTS B;
 </command_text>
          </statement>
          <statement>
            <command_text> 
/*Create table A (id int, groupby int, orderby int, fkb int, search int, padding varchar())*/
CREATE  TABLE A(id int not null primary key, groupby int null, orderby int null, fkb int null, search int null, padding varchar(1000) null)  AS
WITH x AS 
(
  SELECT 0 n FROM dual
  union all 
  SELECT 1 FROM dual
  union all 
  SELECT 2 FROM dual
  union all 
  SELECT 3 FROM dual
  union all 
  SELECT 4 FROM dual
  union all 
  SELECT 5 FROM dual
  union all 
  SELECT 6 FROM dual
  union all 
  SELECT 7 FROM dual
  union all 
  SELECT 8 FROM dual
  union all 
  SELECT 9 FROM dual  
), t1 AS
(
  SELECT ones.n + 10 * tens.n + 100 * hundreds.n + 1000 * thousands.n + 10000 * tenthousands.n + 100000 * hundredthousands.n as id  
  FROM x ones,     x tens,      x hundreds,       x thousands,       x tenthousands,       x hundredthousands
), t2 AS
(
    SELECT  id,
            mod(id, 100) groupby
    FROM t1
), t3 AS
(
    SELECT  b.id, b.groupby, row_number() over (partition by b.groupby order by b.id) orderby
    FROM t2 b
)
SELECT  cast(id as unsigned) id, 
        cast(groupby as unsigned) groupby, 
        cast(orderby as unsigned) orderby,
        cast(mod(orderby, 9173) as unsigned) fkb, 
        cast(mod(id, 911) as unsigned) search, 
        RPAD(concat('Value ', id), 1000, '*') as padding   
FROM t3;



</command_text>
          </statement>
          <statement>
            <command_text>/*Create table B (id int, groupby int, search int, padding varchar())*/
CREATE  TABLE B(id int not null primary key, groupby int null, search int null, padding varchar(1000) null) AS
WITH x AS 
(
  SELECT 0 n FROM dual
  union all 
  SELECT 1 FROM dual
  union all 
  SELECT 2 FROM dual
  union all 
  SELECT 3 FROM dual
  union all 
  SELECT 4 FROM dual
  union all 
  SELECT 5 FROM dual
  union all 
  SELECT 6 FROM dual
  union all 
  SELECT 7 FROM dual
  union all 
  SELECT 8 FROM dual
  union all 
  SELECT 9 FROM dual  
), t1 AS
(
  SELECT ones.n + 10 * tens.n + 100 * hundreds.n + 1000 * thousands.n as id  
  FROM x ones,     x tens,      x hundreds,       x thousands       
)
SELECT  cast(id as unsigned) id,
        cast(mod(id + floor(100000 / (id+1)) , 100) as unsigned) groupby,
        cast(mod(id, 901) as unsigned) search, 
        RPAD(concat('Value ', id), 1000, '*') as padding
FROM t1;
</command_text>
          </statement>
          <statement>
            <command_text>/*insert of some outlier data*/
insert into A(id, groupby, orderby, fkb, search, padding) values (1000000, null, null, null, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000001, 100, null, null, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000002, 99, 10000, null, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000003, 101, 10000, 1, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000004, null, null, 1, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000005, null, null, 500, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000006, null, null, 1, 1, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000007, null, null, null, 1, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into B(id, groupby, search, padding) values (10000, null, null, null);</command_text>
          </statement>
          <statement>
            <command_text>insert into B(id, groupby, search, padding) values (10001, null, 1, null);</command_text>
          </statement>
          <statement>
            <command_text>insert into B(id, groupby, search, padding) values (10002, 1, null, null);</command_text>
          </statement>
          <statement>
            <command_text>insert into B(id, groupby, search, padding) values (10003, 1, 1, null);</command_text>
          </statement>
        </statements>
      </specific_statement_list>
      <specific_statement_list>
        <provider_name>H2</provider_name>
        <statements>
          <statement>
            <command_text>DROP TABLE IF EXISTS a;</command_text>
          </statement>
          <statement>
            <command_text>DROP TABLE IF EXISTS b;</command_text>
          </statement>
          <statement>
            <command_text>CREATE  TABLE A(id int not null primary key, groupby int null, orderby int null, fkb int null, search int null, padding varchar(1000) null)  AS
WITH x AS
(
  SELECT 0 n FROM dual
  union all
  SELECT 1 FROM dual
  union all
  SELECT 2 FROM dual
  union all
  SELECT 3 FROM dual
  union all
  SELECT 4 FROM dual
  union all
  SELECT 5 FROM dual
  union all
  SELECT 6 FROM dual
  union all
  SELECT 7 FROM dual
  union all
  SELECT 8 FROM dual
  union all
  SELECT 9 FROM dual
), t1 AS
(
  SELECT ones.n + 10 * tens.n + 100 * hundreds.n + 1000 * thousands.n + 10000 * tenthousands.n + 100000 * hundredthousands.n as id
  FROM x ones,     x tens,      x hundreds,       x thousands,       x tenthousands,       x hundredthousands
), t2 AS
(
    SELECT  id,
            mod(id, 100) groupby
    FROM t1
), t3 AS
(
    SELECT  b.id, b.groupby, row_number() over (partition by b.groupby order by b.id) orderby
    FROM t2 b
)
SELECT  cast(id as int) id,
        cast(groupby as int) groupby,
        cast(orderby as int) orderby,
        cast(mod(orderby, 9173) as int) fkb,
        cast(mod(id, 911) as int) search,
        RPAD(concat('Value ', id), 1000, '*') as padding
FROM t3;</command_text>
          </statement>
          <statement>
            <command_text>CREATE  TABLE B(id int not null primary key, groupby int null, search int null, padding varchar(1000) null) AS
WITH x AS 
(
  SELECT 0 n FROM dual
  union all 
  SELECT 1 FROM dual
  union all 
  SELECT 2 FROM dual
  union all 
  SELECT 3 FROM dual
  union all 
  SELECT 4 FROM dual
  union all 
  SELECT 5 FROM dual
  union all 
  SELECT 6 FROM dual
  union all 
  SELECT 7 FROM dual
  union all 
  SELECT 8 FROM dual
  union all 
  SELECT 9 FROM dual  
), t1 AS
(
  SELECT ones.n + 10 * tens.n + 100 * hundreds.n + 1000 * thousands.n as id  
  FROM x ones,     x tens,      x hundreds,       x thousands       
)
SELECT  cast(id as int) id,
        cast(mod(id + floor(100000 / (id+1)) , 100) as int) groupby,
        cast(mod(id, 901) as int) search, 
        RPAD(concat('Value ', id), 1000, '*') as padding
FROM t1;</command_text>
          </statement>
          <statement>
            <command_text>/*insert of some outlier data*/
insert into A(id, groupby, orderby, fkb, search, padding) values (1000000, null, null, null, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000001, 100, null, null, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000002, 99, 10000, null, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000003, 101, 10000, 1, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000004, null, null, 1, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000005, null, null, 500, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000006, null, null, 1, 1, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000007, null, null, null, 1, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into B(id, groupby, search, padding) values (10000, null, null, null);</command_text>
          </statement>
          <statement>
            <command_text>insert into B(id, groupby, search, padding) values (10001, null, 1, null);</command_text>
          </statement>
          <statement>
            <command_text>insert into B(id, groupby, search, padding) values (10002, 1, null, null);</command_text>
          </statement>
          <statement>
            <command_text>insert into B(id, groupby, search, padding) values (10003, 1, 1, null);</command_text>
          </statement>
        </statements>
      </specific_statement_list>
      <specific_statement_list>
        <provider_name>Firebird</provider_name>
        <statements>
          <statement>
            <command_text>CREATE TABLE A (
    id int primary key,
    groupby int,
    orderby int,
    fkb int,
    search int,
    padding varchar(1000)
);
</command_text>
          </statement>
          <statement>
            <command_text>CREATE TABLE B (
    id int primary key,
    groupby int,
    search int,
    padding varchar(1000)
);
</command_text>
          </statement>
          <statement>
            <command_text>INSERT INTO A 
WITH x AS 
(
  SELECT 0 n FROM RDB$DATABASE
  union all 
  SELECT 1 FROM RDB$DATABASE
  union all 
  SELECT 2 FROM RDB$DATABASE
  union all 
  SELECT 3 FROM RDB$DATABASE
  union all 
  SELECT 4 FROM RDB$DATABASE
  union all 
  SELECT 5 FROM RDB$DATABASE
  union all 
  SELECT 6 FROM RDB$DATABASE
  union all 
  SELECT 7 FROM RDB$DATABASE
  union all 
  SELECT 8 FROM RDB$DATABASE
  union all 
  SELECT 9 FROM RDB$DATABASE  
), t1 AS
(
  SELECT ones.n + 10 * tens.n + 100 * hundreds.n + 1000 * thousands.n + 10000 * tenthousands.n + 100000 * hundredthousands.n as id  
  FROM x ones,     x tens,      x hundreds,       x thousands,       x tenthousands,       x hundredthousands
), t2 AS
(
    SELECT  id,
            mod(id, 100) groupby
    FROM t1
), t3 AS
(
    SELECT  b.id, b.groupby, row_number() over (partition by b.groupby order by b.id) orderby
    FROM t2 b
)
SELECT  cast(id as int) id, 
        cast(groupby as int) groupby, 
        cast(orderby as int) orderby,
        cast(mod(orderby, 9173) as int) fkb, 
        cast(mod(id, 911) as int) search, 
        RPAD('Value ' || id, 1000, '*') as padding   
FROM t3;
</command_text>
          </statement>
          <statement>
            <command_text>INSERT INTO B
WITH x AS 
(
  SELECT 0 n FROM  RDB$DATABASE
  union all 
  SELECT 1 FROM  RDB$DATABASE
  union all 
  SELECT 2 FROM  RDB$DATABASE
  union all 
  SELECT 3 FROM  RDB$DATABASE
  union all 
  SELECT 4 FROM  RDB$DATABASE
  union all 
  SELECT 5 FROM  RDB$DATABASE
  union all 
  SELECT 6 FROM  RDB$DATABASE
  union all 
  SELECT 7 FROM  RDB$DATABASE
  union all 
  SELECT 8 FROM  RDB$DATABASE
  union all 
  SELECT 9 FROM  RDB$DATABASE  
), t1 AS
(
  SELECT ones.n + 10 * tens.n + 100 * hundreds.n + 1000 * thousands.n as id  
  FROM x ones,     x tens,      x hundreds,       x thousands       
)
SELECT  cast(id as int) id,
        cast(mod(id + floor(100000 / (id+1)) , 100) as int) groupby,
        cast(mod(id, 901) as int) search, 
        RPAD('Value ' || id, 1000, '*') as padding
FROM t1;
</command_text>
          </statement>
          <statement>
            <command_text>/*insert of some outlier data*/
insert into A(id, groupby, orderby, fkb, search, padding) values (1000000, null, null, null, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000001, 100, null, null, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000002, 99, 10000, null, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000003, 101, 10000, 1, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000004, null, null, 1, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000005, null, null, 500, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000006, null, null, 1, 1, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000007, null, null, null, 1, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into B(id, groupby, search, padding) values (10000, null, null, null);</command_text>
          </statement>
          <statement>
            <command_text>insert into B(id, groupby, search, padding) values (10001, null, 1, null);</command_text>
          </statement>
          <statement>
            <command_text>insert into B(id, groupby, search, padding) values (10002, 1, null, null);</command_text>
          </statement>
          <statement>
            <command_text>insert into B(id, groupby, search, padding) values (10003, 1, 1, null);
</command_text>
          </statement>
        </statements>
      </specific_statement_list>
      <specific_statement_list>
        <provider_name>SQLite</provider_name>
        <statements>
          <statement>
            <command_text>DROP TABLE IF EXISTS A;
</command_text>
          </statement>
          <statement>
            <command_text> 
DROP TABLE IF EXISTS B;
 </command_text>
          </statement>
          <statement>
            <command_text>PRAGMA cache_size = 2000000
</command_text>
          </statement>
          <statement>
            <command_text> 
/*Create table A (id int, groupby int, orderby int, fkb int, search int, padding varchar())*/
CREATE  TABLE A AS
WITH x AS 
(
  SELECT 0 AS n
  union all 
  SELECT 1
  union all 
  SELECT 2
  union all 
  SELECT 3
  union all 
  SELECT 4
  union all 
  SELECT 5
  union all 
  SELECT 6
  union all 
  SELECT 7
  union all 
  SELECT 8
  union all 
  SELECT 9 
)
, t1 AS
(
  SELECT ones.n + 10 * tens.n + 100 * hundreds.n + 1000 * thousands.n + 10000 * tenthousands.n + 100000 * hundredthousands.n as id  
  FROM x ones,     x tens,      x hundreds,       x thousands,       x tenthousands,       x hundredthousands
)
, t2 AS
(
    SELECT  id,
    id % 100 groupby
    FROM t1
), t3 AS
(
    SELECT  b.id, b.groupby, row_number() over (partition by b.groupby order by b.id) orderby
    FROM t2 b
)
SELECT  cast(id as unsigned) id, 
        cast(groupby as unsigned) groupby, 
        cast(orderby as unsigned) orderby,
        cast(orderby % 9173 as unsigned) fkb, 
        cast(id % 911 as unsigned) search, 
        SUBSTR('Value ' || id || printf('%.' || 1000 || 'c', '*'), 1, 1000) as padding   
FROM t3;


</command_text>
          </statement>
          <statement>
            <command_text>/*Create table B (id int, groupby int, search int, padding varchar())*/
CREATE  TABLE B AS
WITH x AS 
(
  SELECT 0 n
  union all 
  SELECT 1
  union all 
  SELECT 2
  union all 
  SELECT 3
  union all 
  SELECT 4
  union all 
  SELECT 5
  union all 
  SELECT 6
  union all 
  SELECT 7
  union all 
  SELECT 8
  union all 
  SELECT 9  
), t1 AS
(
  SELECT ones.n + 10 * tens.n + 100 * hundreds.n + 1000 * thousands.n as id  
  FROM x ones,     x tens,      x hundreds,       x thousands       
)
SELECT  cast(id as unsigned) id,
        cast(((id + floor(100000 / (id+1))) % 100) as unsigned) groupby,
        cast((id % 901) as unsigned) search, 
        SUBSTR('Value ' || id || printf('%.' || 1000 || 'c', '*'), 1, 1000) as padding
FROM t1;
</command_text>
          </statement>
          <statement>
            <command_text>/*insert of some outlier data*/
insert into A(id, groupby, orderby, fkb, search, padding) values (1000000, null, null, null, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000001, 100, null, null, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000002, 99, 10000, null, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000003, 101, 10000, 1, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000004, null, null, 1, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000005, null, null, 500, null, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000006, null, null, 1, 1, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into A(id, groupby, orderby, fkb, search, padding) values (1000007, null, null, null, 1, '*');</command_text>
          </statement>
          <statement>
            <command_text>insert into B(id, groupby, search, padding) values (10000, null, null, null);</command_text>
          </statement>
          <statement>
            <command_text>insert into B(id, groupby, search, padding) values (10001, null, 1, null);</command_text>
          </statement>
          <statement>
            <command_text>insert into B(id, groupby, search, padding) values (10002, 1, null, null);</command_text>
          </statement>
          <statement>
            <command_text>insert into B(id, groupby, search, padding) values (10003, 1, 1, null);</command_text>
          </statement>
        </statements>
      </specific_statement_list>
    </specific_statement_lists>
  </init_script>
  <clean_up_script>
    <default_statement_list>
      <statements>
        <statement>
          <command_text>DROP TABLE IF EXISTS A;
</command_text>
        </statement>
        <statement>
          <command_text> 
DROP TABLE IF EXISTS B;
 </command_text>
        </statement>
      </statements>
    </default_statement_list>
    <specific_statement_lists>
      <specific_statement_list>
        <provider_name>Microsoft SQL Server</provider_name>
        <statements>
          <statement>
            <command_text>IF OBJECT_ID('dbo.TestTable', 'U') IS NOT NULL DROP TABLE dbo.TestTable</command_text>
          </statement>
        </statements>
      </specific_statement_list>
      <specific_statement_list>
        <provider_name>Oracle Database</provider_name>
        <statements>
          <statement>
            <command_text>BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE TestTable';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN
         RAISE;
      END IF;
END;
</command_text>
          </statement>
        </statements>
      </specific_statement_list>
      <specific_statement_list>
        <provider_name>PostgreSQL</provider_name>
        <statements>
          <statement>
            <command_text>DROP TABLE IF EXISTS A CASCADE;
</command_text>
          </statement>
          <statement>
            <command_text>DROP TABLE IF EXISTS B CASCADE;
</command_text>
          </statement>
        </statements>
      </specific_statement_list>
      <specific_statement_list>
        <provider_name>Firebird</provider_name>
        <statements>
          <statement>
            <command_text>DROP TABLE A;
</command_text>
          </statement>
          <statement>
            <command_text>DROP TABLE B;
</command_text>
          </statement>
        </statements>
      </specific_statement_list>
      <specific_statement_list>
        <provider_name>MySQL</provider_name>
        <statements>
          <statement>
            <command_text>DROP TABLE IF EXISTS A;
</command_text>
          </statement>
          <statement>
            <command_text> 
DROP TABLE IF EXISTS B;
 </command_text>
          </statement>
        </statements>
      </specific_statement_list>
      <specific_statement_list>
        <provider_name>H2</provider_name>
        <statements>
          <statement>
            <command_text>DROP TABLE IF EXISTS a;</command_text>
          </statement>
          <statement>
            <command_text>DROP TABLE IF EXISTS b;</command_text>
          </statement>
        </statements>
      </specific_statement_list>
    </specific_statement_lists>
  </clean_up_script>
  <test_groups>
    <test_group>
      <id>1005</id>
      <number>I</number>
      <name>1</name>
      <description></description>
      <tests>
        <test>
          <id>1008</id>
          <number>1</number>
          <name>Group By Pushdown</name>
          <description>Group by pushdown is possible only if the group attributes are in the join condition. The condition is thoroughly described in [B9].
The rewrite is cost based, therefore, selection of appropriate version is based on input cardinatilies. </description>
          <active>False</active>
          <variants>
            <variant>
              <id>1009</id>
              <number>a</number>
              <name>Basic</name>
              <description></description>
              <default_statement>
                <command_text>SELECT A.fkb, COUNT(*)
FROM A
JOIN B ON A.fkb = B.id
WHERE A.fkb &lt; 50
GROUP BY A.fkb</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
            <variant>
              <id>1010</id>
              <number>b</number>
              <name>Group By Pushdown</name>
              <description></description>
              <default_statement>
                <command_text>SELECT t.fkb, Ac
FROM (
    SELECT A.fkb, COUNT(*) Ac
    FROM A  
    WHERE A.fkb &lt; 50
    GROUP BY A.fkb
) t
JOIN B ON t.fkb = B.id</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1024</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1026</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1032</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1111</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>0</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1013</id>
          <number>2</number>
          <name>Redundant Semi-Join I</name>
          <description></description>
          <active>False</active>
          <variants>
            <variant>
              <id>1014</id>
              <number>a</number>
              <name>Semi-Join</name>
              <description>The Semi-Join is redundant here because the B.id is primary key. 
Therefore, every tuple from A will match at most one teble from B.</description>
              <default_statement>
                <command_text>SELECT A.id, A.padding
FROM A
WHERE A.fkb IN (
    SELECT B.id
    FROM B
    WHERE B.search = 1
);</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
            <variant>
              <id>1015</id>
              <number>b</number>
              <name>Join</name>
              <description></description>
              <default_statement>
                <command_text>SELECT A.id, A.padding
FROM A
JOIN B ON A.fkb = B.id
WHERE B.search = 1;</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1028</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1032</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>0</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1016</id>
          <number>3</number>
          <name>1:1 Decorrelation</name>
          <description>

Dayal didn't noticed equivalence of these queries (he even claims that they can return different results), however, it is his motivational example.</description>
          <active>False</active>
          <variants>
            <variant>
              <id>1017</id>
              <number>a</number>
              <name>Semi-Join</name>
              <description>There is a 1:1 relationship between A and B that arises from the `A.id IN B.fka AND B.id = A.fkb` condition and the fact that A.id and B.id are primary keys.
Outer-join with delta-projection or semi-join is not necessary here. 
Query can be easily decorrelated into a simple join with two conditions.</description>
              <default_statement>
                <command_text>SELECT A.fkb
FROM A
WHERE A.id in (
  SELECT B.fka
  FROM B
  WHERE B.id = A.fkb
)</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
            <variant>
              <id>1018</id>
              <number>b</number>
              <name>Join</name>
              <description></description>
              <default_statement>
                <command_text>SELECT A.fkb
FROM A
JOIN B ON A.id = B.fka and B.id = A.fkb</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1024</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1032</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>0</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1019</id>
          <number>4</number>
          <name>Decorrelation I</name>
          <description>Decorrelation without aggregates</description>
          <active>False</active>
          <variants>
            <variant>
              <id>1020</id>
              <number>a</number>
              <name>Correlated Subquery</name>
              <description></description>
              <default_statement>
                <command_text>SELECT *
FROM B 
WHERE B.fka IN (
  SELECT A1.id
  FROM A as A1
  WHERE A1.fkb IN (
    SELECT A2.id
    FROM A as A2
    WHERE A2.orderby = B.id
  )
)</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
            <variant>
              <id>1021</id>
              <number>b</number>
              <name>Without Inner Correlation</name>
              <description></description>
              <default_statement>
                <command_text>SELECT *
FROM B 
WHERE B.id IN (
  SELECT A2.orderby
  FROM A as A2
  JOIN A as A1 on A1.fkb = A2.id
  WHERE A1.id = B.fka
)</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1024</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>0</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1033</id>
          <number>5</number>
          <name>Redundant Semi-Join II</name>
          <description>Our example contains also a redundant join (while compared to the SQL in the paper). However, the redundant join can be easily processed and does not represent a substantial overhead.</description>
          <active>False</active>
          <variants>
            <variant>
              <id>1034</id>
              <number>a</number>
              <name>Semi-Join</name>
              <description></description>
              <default_statement>
                <command_text>select *
from A
where exists (
  select 1
  from AB
  join B on AB.fkb = B.id
  where A.id = AB.fka and AB.fkb = 100
)</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
            <variant>
              <id>1035</id>
              <number>b</number>
              <name>Join</name>
              <description></description>
              <default_statement>
                <command_text>select A.*
from A
join AB on A.id = AB.fka 
join B on AB.fkb = B.id
where AB.fkb = 100</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1028</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1032</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>2</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1036</id>
          <number>6</number>
          <name>Necessary Semi-Join</name>
          <description>We need to add DISTINCT after the Semi-Join removal.</description>
          <active>False</active>
          <variants>
            <variant>
              <id>1037</id>
              <number>a</number>
              <name>Semi-Join</name>
              <description></description>
              <default_statement>
                <command_text>select A.id, A.padding
from A
where exists (
  select 1
  from B 
  where A.id = B.fka and B.search &lt; 50
)</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
            <variant>
              <id>1038</id>
              <number>b</number>
              <name>Join</name>
              <description></description>
              <default_statement>
                <command_text>select distinct A.id, A.padding
from A
join B on A.id = B.fka and B.search &lt; 50</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1028</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1032</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>0</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1039</id>
          <number>7</number>
          <name>Intersect</name>
          <description></description>
          <active>False</active>
          <variants>
            <variant>
              <id>1040</id>
              <number>a</number>
              <name>Intersect</name>
              <description></description>
              <default_statement>
                <command_text>SELECT A.id
FROM A
WHERE A.search = 100
INTERSECT
SELECT B.fka
FROM B
WHERE B.search = 100</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
            <variant>
              <id>1041</id>
              <number>b</number>
              <name>Semi-Join</name>
              <description>We ignore the NULL checking that is mentioned in the original paper, since the primary key can not be NULL.</description>
              <default_statement>
                <command_text>SELECT A.id
FROM A
WHERE A.search = 100 and exists(
  SELECT B.fka
  FROM B
  WHERE B.search = 100 and A.id = B.fka
)</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1028</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1032</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>1</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1042</id>
          <number>8</number>
          <name>Except</name>
          <description></description>
          <active>False</active>
          <variants>
            <variant>
              <id>1043</id>
              <number>a</number>
              <name>Except</name>
              <description></description>
              <default_statement>
                <command_text>SELECT A.id
FROM A
WHERE A.search = 100
EXCEPT
SELECT B.fka
FROM B
WHERE B.search &lt; 100</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
            <variant>
              <id>1044</id>
              <number>b</number>
              <name>Semi-Join</name>
              <description></description>
              <default_statement>
                <command_text>SELECT A.id
FROM A
WHERE A.search = 100 and not exists(
  SELECT B.fka
  FROM B
  WHERE B.search &lt; 100 and A.id = B.fka
)</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1032</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1028</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>1096</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1045</id>
          <number>9</number>
          <name>Interset All</name>
          <description>TODO - has to be checked according to the Pauley thesis, page 214</description>
          <active>False</active>
          <variants>
            <variant>
              <id>1046</id>
              <number>a</number>
              <name>Intersect</name>
              <description></description>
              <default_statement>
                <command_text>SELECT A.id
FROM A
WHERE A.search = 100
INTERSECT
SELECT AB.fka
FROM AB
WHERE AB.fkb = 50</command_text>
              </default_statement>
              <specific_statements>
                <specific_statement>
                  <provider_name>Microsoft SQL Server</provider_name>
                  <not_supported>True</not_supported>
                  <command_text></command_text>
                </specific_statement>
              </specific_statements>
              <selected_annotations />
            </variant>
            <variant>
              <id>1047</id>
              <number>b</number>
              <name>Intersect All</name>
              <description></description>
              <default_statement>
                <command_text>SELECT A.id
FROM A
WHERE A.search = 100
INTERSECT ALL
SELECT AB.fka
FROM AB
WHERE AB.fkb = 50</command_text>
              </default_statement>
              <specific_statements>
                <specific_statement>
                  <provider_name>Microsoft SQL Server</provider_name>
                  <not_supported>True</not_supported>
                  <command_text></command_text>
                </specific_statement>
              </specific_statements>
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1028</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1032</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>1</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1048</id>
          <number>10</number>
          <name>Intersect as Join</name>
          <description>A.id, AB.fka needs to be UCC for their queries. AB.fka is a PK because we have a `AB.fkb = 10` condition in the WHERE clause.</description>
          <active>False</active>
          <variants>
            <variant>
              <id>1049</id>
              <number>a</number>
              <name>Intersect</name>
              <description></description>
              <default_statement>
                <command_text>SELECT A.id
FROM A
WHERE A.search = 100
INTERSECT
SELECT AB.fka
FROM AB
WHERE AB.fkb = 10</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
            <variant>
              <id>1050</id>
              <number>b</number>
              <name>Join</name>
              <description></description>
              <default_statement>
                <command_text>SELECT A.id
FROM A
JOIN AB ON A.id = AB.fka
WHERE A.search = 100 and AB.fkb = 10</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1028</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1032</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>0</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1051</id>
          <number>11</number>
          <name>Semi-Join to Join+Group By</name>
          <description>A.id needs to be a primary key, otherwise we need to group by according to some artificial identifier of A.</description>
          <active>False</active>
          <variants>
            <variant>
              <id>1052</id>
              <number>a</number>
              <name>Semi-Join</name>
              <description></description>
              <default_statement>
                <command_text>SELECT A.padding
FROM A
WHERE A.orderby &lt; (
    SELECT AVG(B.search) * 0.05
    FROM B
    WHERE B.fka = A.id
)</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
            <variant>
              <id>1053</id>
              <number>b</number>
              <name>Groupo by</name>
              <description></description>
              <default_statement>
                <command_text>SELECT A.padding
FROM A
JOIN B ON A.id = B.fka
GROUP BY A.id, A.orderby, A.padding
HAVING AVG(B.search) * 0.05 &gt; A.orderby</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1024</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1032</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>0</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1054</id>
          <number>12</number>
          <name>Semi-Join to Outer-Join+Group By</name>
          <description>B.id needs to be a primary key, otherwise we need to group by according to some artificial identifier of B. We have to be carefull about the famous counting bug (Kim 82).</description>
          <active>True</active>
          <variants>
            <variant>
              <id>1055</id>
              <number>a</number>
              <name>Semi-Join</name>
              <description></description>
              <default_statement>
                <command_text>SELECT B.id, B.padding
FROM B
WHERE B.groupby &gt; (
    SELECT COUNT(*) * 10
    FROM AB
    WHERE AB.fkb = B.id
    ) $Bsearch</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
            <variant>
              <id>1056</id>
              <number>b</number>
              <name>Group by</name>
              <description></description>
              <default_statement>
                <command_text>SELECT B.id, B.padding
FROM B
LEFT JOIN AB ON AB.fkb = B.id 
WHERE 1 = 1 $Bsearch
GROUP BY B.id, B.groupby, B.padding
HAVING B.groupby &gt; COUNT(AB.fkb) * 10</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1024</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1032</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>0</expected_result_size>
          <parametrized>True</parametrized>
          <parameters>
            <parameter>
              <id>1061</id>
              <name>Bsearch</name>
            </parameter>
          </parameters>
          <templates>
            <template>
              <id>1057</id>
              <number>Plain</number>
              <expected_result_size>0</expected_result_size>
              <selected_annotations />
            </template>
            <template>
              <id>1058</id>
              <number>B_low_selectivity</number>
              <expected_result_size>0</expected_result_size>
              <selected_annotations />
            </template>
          </templates>
          <parameter_values>
            <parameter_value>
              <template_id>1057</template_id>
              <parameter_id>1061</parameter_id>
              <value></value>
            </parameter_value>
            <parameter_value>
              <template_id>1058</template_id>
              <parameter_id>1061</parameter_id>
              <value>and B.search &lt; 20</value>
            </parameter_value>
          </parameter_values>
        </test>
        <test>
          <id>1062</id>
          <number>13</number>
          <name>Redundant Distinct</name>
          <description></description>
          <active>False</active>
          <variants>
            <variant>
              <id>1063</id>
              <number>a</number>
              <name>Redundant Distinct</name>
              <description></description>
              <default_statement>
                <command_text>SELECT DISTINCT AB.fka, A.padding
FROM A
JOIN AB ON A.id = AB.fka
WHERE AB.fkb = 9000</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations>
                <selected_annotation>
                  <annotation_id>1028</annotation_id>
                </selected_annotation>
                <selected_annotation>
                  <annotation_id>1032</annotation_id>
                </selected_annotation>
                <selected_annotation>
                  <annotation_id>1080</annotation_id>
                </selected_annotation>
              </selected_annotations>
            </variant>
            <variant>
              <id>1064</id>
              <number>b</number>
              <name>Basic</name>
              <description></description>
              <default_statement>
                <command_text>SELECT AB.fka, A.padding
FROM A
JOIN AB ON A.id = AB.fka
WHERE AB.fkb = 9000</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1032</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1028</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>0</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1068</id>
          <number>14</number>
          <name>Predicates Elimination in Self-Join</name>
          <description>Based on Theorem 1. There is a FD id -&gt; groupby orderby and FD groupby orderby -&gt; id. Therefore, there are two posisble atribute removals. We remove larger set. </description>
          <active>True</active>
          <variants>
            <variant>
              <id>1069</id>
              <number>a</number>
              <name>Redundant predicates</name>
              <description></description>
              <default_statement>
                <command_text>SELECT A1.padding, A2.padding
FROM A A1
JOIN A A2 ON A1.id = A2.id and A1.groupby = A2.groupby and A1.orderby = A2.orderby
WHERE A1.groupby = 1 and A2.search = 1</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
            <variant>
              <id>1070</id>
              <number>b</number>
              <name>Non-redundant</name>
              <description>We have to be careful about NULL values when dealing with equivalence</description>
              <default_statement>
                <command_text>SELECT A1.padding, A2.padding
FROM A A1
JOIN A A2 ON A1.id = A2.id
WHERE A1.groupby = 1 and A2.search = 1 and A2.orderby is not null</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1065</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1066</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1032</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>0</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1071</id>
          <number>15</number>
          <name>Semi-Join Elimination</name>
          <description>Description in Example 2 in Kambayashi in not completely accurate. The FD empt -&gt; B has to be satisfied in both relations as mentioned in theorem ! However, we can create a test based on their description.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>1072</id>
              <number>a</number>
              <name>Semi-Join</name>
              <description></description>
              <default_statement>
                <command_text>SELECT B.id, B.padding
FROM B
WHERE exists(
  SELECT A.id
  FROM A
  WHERE A.groupby = 10 and 
    B.groupby = A.groupby
) </command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
            <variant>
              <id>1073</id>
              <number>b</number>
              <name>Basic</name>
              <description></description>
              <default_statement>
                <command_text>SELECT B.id, B.padding
FROM B
WHERE exists(
  SELECT A.id
  FROM A
  WHERE A.groupby = 10
) and B.groupby = 10</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1065</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1066</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>0</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1074</id>
          <number>16</number>
          <name>Redundant Self-Join</name>
          <description>The rewrintg technique is described in section 8.2 of [B5]. </description>
          <active>True</active>
          <variants>
            <variant>
              <id>1078</id>
              <number>a</number>
              <name>Self-Join</name>
              <description></description>
              <default_statement>
                <command_text>SELECT B1.id, B2.padding
FROM B B1
JOIN B B2 ON B1.id = B2.id
WHERE B1.search = 100 and B2.groupby = 10</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
            <variant>
              <id>1079</id>
              <number>b</number>
              <name>Basic</name>
              <description></description>
              <default_statement>
                <command_text>SELECT B.id, B.padding
FROM B
WHERE search = 100 and groupby = 10</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1075</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1032</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>0</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1087</id>
          <number>17</number>
          <name>Redundant Inner-Join I</name>
          <description>The redundant Join with table B is possible because B.id is a primary key and AB.fkb and A.fkb are a foreign keys.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>1088</id>
              <number>a</number>
              <name>Redundant Join</name>
              <description></description>
              <default_statement>
                <command_text>SELECT A.id, A.padding, A.padding, AB.fka
FROM AB
JOIN B ON B.id = AB.fkb
JOIN A ON B.id = A.fkb
WHERE A.search = 100 and AB.fka = 10</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
            <variant>
              <id>1089</id>
              <number>b</number>
              <name>Basic</name>
              <description></description>
              <default_statement>
                <command_text>SELECT A.id, A.padding, A.padding, AB.fka
FROM AB
JOIN A ON AB.fkb = A.fkb
WHERE A.search = 100 and AB.fka = 10 and AB.fkb is not null</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1080</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1083</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1032</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1109</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>0</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1090</id>
          <number>18</number>
          <name>Redundant Inner-Join II</name>
          <description>Basic assuptions are: B.id is a primary key and A.fka is foreign key.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>1091</id>
              <number>a</number>
              <name>Redundant Join</name>
              <description></description>
              <default_statement>
                <command_text>SELECT A.id, A.padding, A.padding
FROM B 
JOIN A ON B.id = A.fkb
WHERE A.search = 100</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
            <variant>
              <id>1092</id>
              <number>b</number>
              <name>Basic</name>
              <description></description>
              <default_statement>
                <command_text>SELECT A.id, A.padding, A.padding
FROM A 
WHERE A.search = 100 and A.fkb is not null</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1080</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1083</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1032</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>0</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1093</id>
          <number>19</number>
          <name>Predicate Introduction</name>
          <description>The predicate introduction can benefit from an existence of an index. In this particular case we have an index A(groupby,orderby) because these atributes are marked unique.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>1094</id>
              <number>a</number>
              <name>Basic</name>
              <description></description>
              <default_statement>
                <command_text>SELECT A.id, A.search, A.padding
FROM A
WHERE A.search = A.groupby and A.search = 10</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
            <variant>
              <id>1095</id>
              <number>b</number>
              <name>Extra predicate</name>
              <description></description>
              <default_statement>
                <command_text>SELECT A.id, A.search, A.padding
FROM A
WHERE A.search = 10 and A.groupby = 10</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1080</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1032</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>0</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1096</id>
          <number>20</number>
          <name>Quantifier change</name>
          <description>The rewriting is based on the existence of the `group by order by -&gt; fd_groupby_orderby` functional dependency. fd_groupby_orderby attribute can not be null.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>1097</id>
              <number>a</number>
              <name>ALL</name>
              <description></description>
              <default_statement>
                <command_text>SELECT *
FROM B 
WHERE search = ALL (
    SELECT fd_groupby_orderby
    FROM A
    WHERE A.groupby = 10 and A.orderby = 10
)</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
            <variant>
              <id>1098</id>
              <number>b</number>
              <name>EXISTS</name>
              <description></description>
              <default_statement>
                <command_text>SELECT *
FROM B 
WHERE exists (
    SELECT 1
    FROM A
    WHERE A.groupby = 10 and A.orderby = 10 and B.search = A.fd_groupby_orderby
)</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1066</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>0</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1102</id>
          <number>21</number>
          <name>Redundant Order By Attributes</name>
          <description>The rewriting is based on a existence of the F1 `A.id -&gt; A.groupby` functional dependecy (since A.id is PK).
Temporary FD F2 `B.fka -&gt; A.id` created after JOIN with `B.fka = A.id`.
FD F3 `B.fka -&gt; A.groupby` is deducted based on transitivity.
The F3 is used to reduce the attributes in ORDER BY.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>1103</id>
              <number>a</number>
              <name>Full Order By</name>
              <description></description>
              <default_statement>
                <command_text>SELECT *
FROM B 
JOIN A ON B.fka = A.id
WHERE B.groupby &lt; 50
ORDER BY B.fka, A.groupby</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
            <variant>
              <id>1104</id>
              <number>b</number>
              <name>Reduced Order By</name>
              <description></description>
              <default_statement>
                <command_text>SELECT *
FROM B 
JOIN A ON B.fka = A.id
WHERE B.groupby &lt; 50
ORDER BY B.fka</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations>
                <selected_annotation>
                  <annotation_id>1099</annotation_id>
                </selected_annotation>
                <selected_annotation>
                  <annotation_id>1083</annotation_id>
                </selected_annotation>
              </selected_annotations>
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1099</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1083</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1105</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1107</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>0</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1114</id>
          <number>22</number>
          <name>Redundant Scalar Subquery Reduction I</name>
          <description>Reduction is based on a containement of a subquery and outer query.</description>
          <active>True</active>
          <variants>
            <variant>
              <id>1115</id>
              <number>a</number>
              <name>Redundant Scalar Subquery</name>
              <description></description>
              <default_statement>
                <command_text>SELECT *
FROM B 
JOIN A ON B.fka = A.id
WHERE B.id = (
  SELECT A.groupby
  FROM A
  WHERE B.fka = A.id
)</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
            <variant>
              <id>1116</id>
              <number>b</number>
              <name>Basic</name>
              <description></description>
              <default_statement>
                <command_text>SELECT B.*
FROM B 
JOIN A ON B.id = A.groupby and B.fka = A.id</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1117</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>0</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1120</id>
          <number>23</number>
          <name>Redundant Scalar Subquery Reduction II</name>
          <description></description>
          <active>True</active>
          <variants>
            <variant>
              <id>1121</id>
              <number>a</number>
              <name>Redundant Scalar Subquery</name>
              <description></description>
              <default_statement>
                <command_text>SELECT *
FROM B 
JOIN A ON B.fka = A.id
WHERE (
  SELECT A.search
  FROM A
  WHERE B.fka = A.id
) = 1</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
            <variant>
              <id>1122</id>
              <number>b</number>
              <name>Basic</name>
              <description></description>
              <default_statement>
                <command_text>SELECT *
FROM B 
JOIN A ON B.fka = A.id
WHERE A.search = 1</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1117</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>0</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1123</id>
          <number>24</number>
          <name>Redundant Order By and Limit 1</name>
          <description>The attribute `id` in table A has to be UCC </description>
          <active>True</active>
          <variants>
            <variant>
              <id>1124</id>
              <number>a</number>
              <name>Redundant Limit 1 and ORDER BY</name>
              <description></description>
              <default_statement>
                <command_text>SELECT MIN(Asearch)
FROM (
    SELECT (
      SELECT A.search
      FROM A
      WHERE AB.fka = A.id
      ORDER BY A.id
      LIMIT 1
    ) Asearch
    FROM AB 
    WHERE AB.fkb &gt; 9000
) t</command_text>
              </default_statement>
              <specific_statements>
                <specific_statement>
                  <provider_name>Microsoft SQL Server</provider_name>
                  <not_supported>False</not_supported>
                  <command_text>SELECT MIN(Asearch)
FROM (
    SELECT (
      SELECT TOP 1 A.search
      FROM A
      WHERE AB.fka = A.id
      ORDER BY A.id
    ) Asearch
    FROM AB 
    WHERE AB.fkb &gt; 9000
) t</command_text>
                </specific_statement>
              </specific_statements>
              <selected_annotations />
            </variant>
            <variant>
              <id>1125</id>
              <number>b</number>
              <name>Basic</name>
              <description></description>
              <default_statement>
                <command_text>
SELECT MIN(Asearch)
FROM (
    SELECT (
      SELECT A.search
      FROM A
      WHERE AB.fka = A.id
    ) Asearch
    FROM AB 
    WHERE AB.fkb &gt; 9000
) t</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1032</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>0</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1126</id>
          <number>25</number>
          <name>Redundant Aggregation</name>
          <description>The attribute `id` in table A has to be UCC </description>
          <active>True</active>
          <variants>
            <variant>
              <id>1127</id>
              <number>a</number>
              <name>Redundant Aggregation</name>
              <description></description>
              <default_statement>
                <command_text>SELECT MIN(Asearch)
FROM (
    SELECT (
      SELECT MAX(A.search)
      FROM A
      WHERE AB.fka = A.id
    ) Asearch
    FROM AB 
    WHERE AB.fkb &gt; 9000
) t</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
            <variant>
              <id>1128</id>
              <number>b</number>
              <name>Basic</name>
              <description></description>
              <default_statement>
                <command_text>SELECT MIN(Asearch)
FROM (
    SELECT (
      SELECT A.search
      FROM A
      WHERE AB.fka = A.id
    ) Asearch
    FROM AB 
    WHERE AB.fkb &gt; 9000
) t</command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1032</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>0</expected_result_size>
          <parametrized>False</parametrized>
        </test>
        <test>
          <id>1129</id>
          <number>26</number>
          <name>Subquery Coalescing based on Containment</name>
          <description></description>
          <active>True</active>
          <variants>
            <variant>
              <id>1132</id>
              <number>a</number>
              <name>Redundant Subquery</name>
              <description></description>
              <default_statement>
                <command_text>SELECT *
FROM AB 
WHERE EXISTS(
  SELECT 1
  FROM A
  WHERE AB.fka = A.id $Pred
) $LogicalOp EXISTS(
  SELECT 1
  FROM A
  WHERE AB.fka = A.id and A.search &lt; 10
) </command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
            <variant>
              <id>1133</id>
              <number>b</number>
              <name>Basic</name>
              <description></description>
              <default_statement>
                <command_text>SELECT *
FROM AB 
WHERE EXISTS(
  SELECT 1
  FROM A
  WHERE AB.fka = A.id and A.search &lt; 10
) </command_text>
              </default_statement>
              <specific_statements />
              <selected_annotations />
            </variant>
          </variants>
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1130</annotation_id>
            </selected_annotation>
            <selected_annotation>
              <annotation_id>1117</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>0</expected_result_size>
          <parametrized>True</parametrized>
          <parameters>
            <parameter>
              <id>1135</id>
              <name>LogicalOp</name>
            </parameter>
            <parameter>
              <id>1138</id>
              <name>Pred</name>
            </parameter>
          </parameters>
          <templates>
            <template>
              <id>1136</id>
              <number>i</number>
              <expected_result_size>10885</expected_result_size>
              <selected_annotations />
            </template>
            <template>
              <id>1139</id>
              <number>ii</number>
              <expected_result_size>10885</expected_result_size>
              <selected_annotations />
            </template>
          </templates>
          <parameter_values>
            <parameter_value>
              <template_id>1136</template_id>
              <parameter_id>1135</parameter_id>
              <value>AND</value>
            </parameter_value>
            <parameter_value>
              <template_id>1136</template_id>
              <parameter_id>1138</parameter_id>
              <value></value>
            </parameter_value>
            <parameter_value>
              <template_id>1139</template_id>
              <parameter_id>1135</parameter_id>
              <value>OR</value>
            </parameter_value>
            <parameter_value>
              <template_id>1139</template_id>
              <parameter_id>1138</parameter_id>
              <value>and A.search &lt; 10 and A.groupby &gt; 10</value>
            </parameter_value>
          </parameter_values>
        </test>
        <test>
          <id>1140</id>
          <number>27</number>
          <name>Subquery Coalescing based on Similar Queries</name>
          <description>Two disjunctive subqueries can be merged even when they are not contained. For example if they differ in just conjunctive predicates.</description>
          <active>True</active>
          <variants />
          <selected_annotations>
            <selected_annotation>
              <annotation_id>1130</annotation_id>
            </selected_annotation>
          </selected_annotations>
          <expected_result_size>0</expected_result_size>
          <parametrized>False</parametrized>
        </test>
      </tests>
      <configurations>
        <configuration>
          <id>1006</id>
          <number>A</number>
          <name>Heap</name>
          <description></description>
          <init_script>
            <default_statement_list>
              <statements />
            </default_statement_list>
            <specific_statement_lists />
          </init_script>
          <clean_up_script>
            <default_statement_list>
              <statements />
            </default_statement_list>
            <specific_statement_lists />
          </clean_up_script>
        </configuration>
        <configuration>
          <id>1007</id>
          <number>B</number>
          <name>Indexed</name>
          <description></description>
          <init_script>
            <default_statement_list>
              <statements>
                <statement>
                  <command_text>CREATE NONCLUSTERED INDEX ix_A_fkb
ON A (fkb)
</command_text>
                </statement>
                <statement>
                  <command_text>CREATE NONCLUSTERED INDEX ix_A_fkb_groupby
ON A (fkb, groupby)
</command_text>
                </statement>
                <statement>
                  <command_text>CREATE NONCLUSTERED INDEX ix_B_search
ON B (search)
</command_text>
                </statement>
              </statements>
            </default_statement_list>
            <specific_statement_lists />
          </init_script>
          <clean_up_script>
            <default_statement_list>
              <statements />
            </default_statement_list>
            <specific_statement_lists />
          </clean_up_script>
        </configuration>
      </configurations>
    </test_group>
  </test_groups>
  <connection_settings>
    <current_provider>Microsoft SQL Server</current_provider>
    <providers>
      <provider name="Microsoft SQL Server" use_connection_string="true" data_source="" initial_catalog="" integrated_security="true" user_id="" password="" connection_string="Server=bayer.cs.vsb.cz\SQLDB;Database=sqlbench_mysql;User Id=sqlbench;Password=sqlbench2019;timeout=250" disable_parallel_query_processing="true" />
      <provider name="Oracle Database" use_connection_string="false" user_name="bac027" password="viy0QWuyCz" host_name="bayer.cs.vsb.cz" port="1521" s_id="oracle" connection_string="" command_timeout="250" disable_parallel_query_processing="true" />
      <provider name="PostgreSQL" use_connection_string="false" host="dbsys.cs.vsb.cz" user_name="querybenchmark" password="cQSZoKMH1Z" database="querybenchmark" command_timeout="250" connection_string="" disable_parallel_query_processing="true" />
      <provider name="MySQL" use_connection_string="false" host_name="bayer.cs.vsb.cz" user_name="sqlbench" password="n3cUmubsbo" default_schema="sqlbench" connection_string="jdbc:mysql://bayer.cs.vsb.cz:3306/sqlbench" command_timeout="300" />
      <provider name="SQLite" use_connection_string="false" file_name="E:\users\bac027\git\QueryOptimizerBenchmark\benchmark_runner\test2.sqlite" in_memory="true" connection_string="" command_timeout="250" />
      <provider name="H2" use_connection_string="false" url="jdbc:h2:tcp://dbsys.cs.vsb.cz/~/test" user_name="sqlbench" password="n3cUmubsbo" connection_string="" command_timeout="250" />
      <provider name="Firebird" use_connection_string="false" host_name="dbsys.cs.vsb.cz" user_name="sqlbenchuser" password="n3cUmubsbo" database="sqlbench" admin_role="false" connection_string="" command_timeout="250" />
    </providers>
  </connection_settings>
  <test_runs />
  <annotations>
    <annotation>
      <id>1024</id>
      <number>B1</number>
      <name>Dayal_VLDB_1987</name>
      <description>Dayal, Umeshwar. Of Nests aud Trees: A Untied Approach to Processing Queries That Contain Nested Subqueries, Aggregates, and Quantifiers. In: Proceedings of the International Conference on Very Large Databases (VLDB), pp. 197–208 (1987)</description>
    </annotation>
    <annotation>
      <id>1026</id>
      <number>B2</number>
      <name>Surajit_et_VLDB_1994</name>
      <description>Chaudhuri, Surajit, and Kyuseok Shim. Including group-by in query optimization. In: Proceedings of the International Conference on Very Large Databases (VLDB), pp. 354–366 (1994).</description>
    </annotation>
    <annotation>
      <id>1028</id>
      <number>B3</number>
      <name>Paulley_et_ICDE_1994</name>
      <description>Paulley, G.N., Larson, P.: Exploiting uniqueness in query optimization. In: Proceedings of the International Conference on Data Engineering (ICDE), pp. 68–79 (1994)</description>
    </annotation>
    <annotation>
      <id>1032</id>
      <number>DD1</number>
      <name>UCC</name>
      <description>Rewriting is dependent on the existence of some unique combination of columns (UCC). </description>
    </annotation>
    <annotation>
      <id>1065</id>
      <number>B4</number>
      <name>Kambayashi_et_SIGMOD_1983</name>
      <description>Kambayashi, Yahiko, and Masatoshi Yoshikawa. "Query processing utilizing dependencies and horizontal decomposition." In Proceedings of the 1983 ACM SIGMOD international conference on Management of data, pp. 55-67. 1983.</description>
    </annotation>
    <annotation>
      <id>1066</id>
      <number>DD2</number>
      <name>FD</name>
      <description>Rewriting uses existence of some FD</description>
    </annotation>
    <annotation>
      <id>1075</id>
      <number>B5</number>
      <name>Abiteboul_et_al_1995</name>
      <description>Abiteboul, S., Hull, R., Vianu, V.: Foundations of Databases. Addison-Wesley, Boston (1995)</description>
    </annotation>
    <annotation>
      <id>1080</id>
      <number>B6</number>
      <name>Chen_et_VLDB_1999</name>
      <description>Cheng, Qi, Jarek Gryz, Fred Koo, TY Cliff Leung, Linqi Liu, Xiaoyan Qian, and Bernhard Schiefer. "Implementation of two semantic query optimization techniques in DB2 universal database." In VLDB, vol. 99, pp. 687-698. 1999.</description>
    </annotation>
    <annotation>
      <id>1083</id>
      <number>DD3</number>
      <name>FK</name>
      <description>Rewriting is dependent on the existence of some inclusion dependencies (foreign key).</description>
    </annotation>
    <annotation>
      <id>1099</id>
      <number>B7</number>
      <name>Simmen_et_SIGMOD_1996</name>
      <description>Simmen, D.E., Shekita, E.J., Malkemus, T.: Fundamental techniques for order optimization. In: Proceedings of the International Conference on Management of Data (SIGMOD), pp. 57–67 (1996)</description>
    </annotation>
    <annotation>
      <id>1105</id>
      <number>F1</number>
      <name>Temporal FD</name>
      <description>Flag indicating that the equivalence is based on temporary FD</description>
    </annotation>
    <annotation>
      <id>1107</id>
      <number>F2</number>
      <name>Derivation of FD</name>
      <description>Flag indicating that the equivalence is based on a FD derivation</description>
    </annotation>
    <annotation>
      <id>1109</id>
      <number>B8</number>
      <name>Casanova_et_al_SIGMOD_1982</name>
      <description>Casanova, Marco A., Ronald Fagin, and Christos H. Papadimitriou.: Inclusion dependencies and their interaction with functional dependencies. In Proceedings of the 1st ACM SIGACT-SIGMOD symposium on Principles of database systems, pp. 171-176. 1982.</description>
    </annotation>
    <annotation>
      <id>1111</id>
      <number>B9</number>
      <name>Yan_et_al_ICDE_1994</name>
      <description>Yan, W.P., Larson, P.: Performing group-by before join. In: Proceedings of the International Conference on Data Engineering (ICDE), pp. 89–100 (1994)</description>
    </annotation>
    <annotation>
      <id>1117</id>
      <number>QD1</number>
      <name>CON</name>
      <description>Part of the query is contained in other part of the query</description>
    </annotation>
    <annotation>
      <id>1130</id>
      <number>B10</number>
      <name>Bellamkonda_et_al_VLDB_2009</name>
      <description>Bellamkonda, Srikanth, Rafi Ahmed, Andrew Witkowski, Angela Amor, Mohamed Zait, and Chun-Chieh Lin. "Enhanced subquery optimizations in oracle." Proceedings of the VLDB Endowment 2, no. 2 (2009): 1366-1377.</description>
    </annotation>
  </annotations>
  <test_run_settings>
    <run_init_script>True</run_init_script>
    <run_clean_up_script>False</run_clean_up_script>
    <check_result_sizes>False</check_result_sizes>
    <compare_results>False</compare_results>
    <query_runs>5</query_runs>
    <test_loops>1</test_loops>
    <close_on_complete>False</close_on_complete>
    <ignore_annotations />
  </test_run_settings>
  <last_id>1140</last_id>
</sql_benchmark>